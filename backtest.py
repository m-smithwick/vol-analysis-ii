"""
Backtesting module for volume analysis signals.

This module analyzes the historical performance of entry and exit signals
generated by the volume analysis tool.
"""

import pandas as pd
import numpy as np
from datetime import datetime
from typing import Dict, List, Tuple, Optional


def calculate_forward_returns(df: pd.DataFrame, periods: List[int] = [1, 10]) -> pd.DataFrame:
    """
    Calculate forward returns for different time periods.
    Note: Only used for internal calculations. Entry-to-exit analysis is preferred.
    
    Args:
        df (pd.DataFrame): DataFrame with Close prices
        periods (List[int]): List of forward periods to calculate
        
    Returns:
        pd.DataFrame: Original DataFrame with forward return columns added
    """
    df_returns = df.copy()
    
    for period in periods:
        # Calculate forward returns
        df_returns[f'Forward_Return_{period}d'] = (
            (df_returns['Close'].shift(-period) - df_returns['Close']) / df_returns['Close'] * 100
        )
    
    return df_returns


def analyze_signal_performance(df: pd.DataFrame, signal_column: str, signal_name: str, 
                               forward_periods: List[int] = [5, 20]) -> Dict:
    """
    Analyze performance of a specific signal type.
    
    Args:
        df (pd.DataFrame): DataFrame with signals and forward returns
        signal_column (str): Column name containing signal boolean flags
        signal_name (str): Human-readable name for the signal
        forward_periods (List[int]): Periods to analyze
        
    Returns:
        Dict: Performance metrics for the signal
    """
    # Get all occurrences of this signal
    signal_dates = df[df[signal_column] == True]
    
    if len(signal_dates) == 0:
        return {
            'signal_name': signal_name,
            'count': 0,
            'metrics': {}
        }
    
    metrics = {
        'signal_name': signal_name,
        'count': len(signal_dates),
        'metrics': {}
    }
    
    for period in forward_periods:
        forward_col = f'Forward_Return_{period}d'
        
        if forward_col not in signal_dates.columns:
            continue
        
        # Remove NaN values (signals near end of data)
        valid_returns = signal_dates[forward_col].dropna()
        
        if len(valid_returns) == 0:
            continue
        
        # Calculate statistics
        wins = valid_returns[valid_returns > 0]
        losses = valid_returns[valid_returns <= 0]
        
        win_rate = (len(wins) / len(valid_returns)) * 100 if len(valid_returns) > 0 else 0
        avg_return = valid_returns.mean()
        avg_win = wins.mean() if len(wins) > 0 else 0
        avg_loss = losses.mean() if len(losses) > 0 else 0
        best_return = valid_returns.max()
        worst_return = valid_returns.min()
        median_return = valid_returns.median()
        
        # Calculate expectancy
        expectancy = (win_rate/100 * avg_win) + ((1-win_rate/100) * avg_loss)
        
        # Find best and worst signals
        best_signal_idx = valid_returns.idxmax()
        worst_signal_idx = valid_returns.idxmin()
        
        metrics['metrics'][f'{period}d'] = {
            'valid_signals': len(valid_returns),
            'win_rate': win_rate,
            'wins': len(wins),
            'losses': len(losses),
            'avg_return': avg_return,
            'avg_win': avg_win,
            'avg_loss': avg_loss,
            'best_return': best_return,
            'worst_return': worst_return,
            'median_return': median_return,
            'expectancy': expectancy,
            'best_signal_date': best_signal_idx.strftime('%Y-%m-%d') if best_signal_idx else None,
            'worst_signal_date': worst_signal_idx.strftime('%Y-%m-%d') if worst_signal_idx else None
        }
    
    return metrics


def analyze_exit_signals(df: pd.DataFrame) -> Dict:
    """
    Analyze the effectiveness of exit signals.
    
    Args:
        df (pd.DataFrame): DataFrame with exit signals and forward returns
        
    Returns:
        Dict: Exit signal performance metrics
    """
    exit_signals = {
        'Profit_Taking': 'ğŸŸ  Profit Taking',
        'Distribution_Warning': 'âš ï¸ Distribution Warning',
        'Sell_Signal': 'ğŸ”´ Sell Signal',
        'Momentum_Exhaustion': 'ğŸ’œ Momentum Exhaustion',
        'Stop_Loss': 'ğŸ›‘ Stop Loss'
    }
    
    results = {}
    
    for signal_col, signal_name in exit_signals.items():
        signal_dates = df[df[signal_col] == True]
        
        if len(signal_dates) == 0:
            continue
        
        # For exit signals, we want to see if price declined after the signal
        forward_20d = signal_dates['Forward_Return_20d'].dropna()
        
        if len(forward_20d) == 0:
            continue
        
        # Count how many times price declined after exit signal (signal was "correct")
        declines = forward_20d[forward_20d < 0]
        correct_exits = len(declines)
        
        avg_decline = forward_20d.mean()
        max_decline = forward_20d.min()
        
        results[signal_col] = {
            'signal_name': signal_name,
            'count': len(signal_dates),
            'valid_signals': len(forward_20d),
            'correct_exits': correct_exits,
            'accuracy': (correct_exits / len(forward_20d)) * 100 if len(forward_20d) > 0 else 0,
            'avg_subsequent_return': avg_decline,
            'max_decline': max_decline
        }
    
    return results


def calculate_system_metrics(df: pd.DataFrame, entry_signals: List[str]) -> Dict:
    """
    Calculate overall system performance metrics.
    
    Args:
        df (pd.DataFrame): DataFrame with all signals and returns
        entry_signals (List[str]): List of entry signal column names
        
    Returns:
        Dict: Overall system metrics
    """
    # Combine all entry signals
    df['Any_Entry_Signal'] = df[entry_signals].any(axis=1)
    
    all_signals = df[df['Any_Entry_Signal'] == True]
    
    if len(all_signals) == 0:
        return {}
    
    # Calculate returns for all signals
    forward_20d = all_signals['Forward_Return_20d'].dropna()
    
    if len(forward_20d) == 0:
        return {}
    
    wins = forward_20d[forward_20d > 0]
    losses = forward_20d[forward_20d <= 0]
    
    win_rate = (len(wins) / len(forward_20d)) * 100
    avg_return = forward_20d.mean()
    
    # Calculate Sharpe-like ratio (return / volatility)
    sharpe = avg_return / forward_20d.std() if forward_20d.std() > 0 else 0
    
    # Maximum drawdown from entry signals
    cumulative_returns = (1 + forward_20d / 100).cumprod()
    running_max = cumulative_returns.expanding().max()
    drawdown = ((cumulative_returns - running_max) / running_max) * 100
    max_drawdown = drawdown.min()
    
    return {
        'total_signals': len(all_signals),
        'valid_signals': len(forward_20d),
        'win_rate': win_rate,
        'avg_return': avg_return,
        'sharpe_ratio': sharpe,
        'max_drawdown': max_drawdown,
        'total_wins': len(wins),
        'total_losses': len(losses)
    }


def generate_backtest_report(df: pd.DataFrame, ticker: str, period: str) -> str:
    """
    Generate a comprehensive backtest report.
    
    Args:
        df (pd.DataFrame): DataFrame with signals and calculated returns
        ticker (str): Stock ticker symbol
        period (str): Analysis period
        
    Returns:
        str: Formatted backtest report
    """
    report_lines = []
    
    # Header
    report_lines.append("=" * 70)
    report_lines.append(f"ğŸ“Š BACKTEST ANALYSIS FOR {ticker.upper()} ({period})")
    report_lines.append("=" * 70)
    report_lines.append("")
    
    # Entry signal definitions
    entry_signals = {
        'Strong_Buy': 'ğŸŸ¢ Strong Buy',
        'Moderate_Buy': 'ğŸŸ¡ Moderate Buy',
        'Stealth_Accumulation': 'ğŸ’ Stealth Accumulation',
        'Confluence_Signal': 'â­ Multi-Signal Confluence',
        'Volume_Breakout': 'ğŸ”¥ Volume Breakout'
    }
    
    # Analyze each entry signal type
    report_lines.append("ğŸ¯ ENTRY SIGNAL PERFORMANCE:")
    report_lines.append("")
    
    best_signal = None
    best_win_rate = 0
    
    for signal_col, signal_name in entry_signals.items():
        metrics = analyze_signal_performance(df, signal_col, signal_name, [5, 20])
        
        if metrics['count'] == 0:
            report_lines.append(f"  {signal_name}:")
            report_lines.append(f"    No signals generated")
            report_lines.append("")
            continue
        
        report_lines.append(f"  {signal_name}:")
        report_lines.append(f"    Total Signals: {metrics['count']}")
        
        # 5-day performance
        if '5d' in metrics['metrics']:
            m = metrics['metrics']['5d']
            report_lines.append(f"    ")
            report_lines.append(f"    5-Day Forward Returns:")
            report_lines.append(f"      Win Rate: {m['win_rate']:.1f}% ({m['wins']} wins, {m['losses']} losses)")
            report_lines.append(f"      Avg Return: {m['avg_return']:+.2f}%")
            report_lines.append(f"      Avg Win: {m['avg_win']:+.2f}% | Avg Loss: {m['avg_loss']:+.2f}%")
            report_lines.append(f"      Expectancy: {m['expectancy']:+.2f}%")
        
        # 20-day performance
        if '20d' in metrics['metrics']:
            m = metrics['metrics']['20d']
            report_lines.append(f"    ")
            report_lines.append(f"    20-Day Forward Returns:")
            report_lines.append(f"      Win Rate: {m['win_rate']:.1f}% ({m['wins']} wins, {m['losses']} losses)")
            report_lines.append(f"      Avg Return: {m['avg_return']:+.2f}%")
            report_lines.append(f"      Best Signal: {m['best_signal_date']} ({m['best_return']:+.2f}%)")
            report_lines.append(f"      Worst Signal: {m['worst_signal_date']} ({m['worst_return']:+.2f}%)")
            report_lines.append(f"      Median Return: {m['median_return']:+.2f}%")
            
            # Track best signal type
            if m['win_rate'] > best_win_rate and m['valid_signals'] >= 3:
                best_win_rate = m['win_rate']
                best_signal = signal_name
        
        report_lines.append("")
    
    # Exit signal performance
    report_lines.append("ğŸšª EXIT SIGNAL PERFORMANCE:")
    report_lines.append("")
    
    exit_results = analyze_exit_signals(df)
    
    if exit_results:
        for signal_col, metrics in exit_results.items():
            report_lines.append(f"  {metrics['signal_name']}:")
            report_lines.append(f"    Signals: {metrics['count']}")
            report_lines.append(f"    Correct Exits: {metrics['correct_exits']}/{metrics['valid_signals']} ({metrics['accuracy']:.1f}%)")
            report_lines.append(f"    Avg Subsequent Return: {metrics['avg_subsequent_return']:+.2f}% (20-day)")
            
            if metrics['accuracy'] >= 70:
                report_lines.append(f"    âœ… Highly reliable exit indicator")
            elif metrics['accuracy'] >= 50:
                report_lines.append(f"    âœ“ Moderately reliable exit indicator")
            else:
                report_lines.append(f"    âš ï¸  Less reliable - use with caution")
            
            report_lines.append("")
    else:
        report_lines.append("  No exit signals generated in this period")
        report_lines.append("")
    
    # Overall system metrics
    report_lines.append("ğŸ“ˆ OVERALL SYSTEM STATISTICS:")
    report_lines.append("")
    
    system_metrics = calculate_system_metrics(df, list(entry_signals.keys()))
    
    if system_metrics:
        report_lines.append(f"  Total Entry Signals: {system_metrics['total_signals']}")
        report_lines.append(f"  Valid for Analysis: {system_metrics['valid_signals']} (have 20-day forward data)")
        report_lines.append(f"  System Win Rate: {system_metrics['win_rate']:.1f}% ({system_metrics['total_wins']} wins, {system_metrics['total_losses']} losses)")
        report_lines.append(f"  Average Return per Signal: {system_metrics['avg_return']:+.2f}%")
        report_lines.append(f"  Risk-Adjusted Return: {system_metrics['sharpe_ratio']:.2f}")
        report_lines.append(f"  Maximum Drawdown: {system_metrics['max_drawdown']:.2f}%")
        report_lines.append("")
    
    # Key insights
    report_lines.append("ğŸ’¡ KEY INSIGHTS:")
    report_lines.append("")
    
    if best_signal:
        report_lines.append(f"  âœ… Most Reliable Signal: {best_signal} ({best_win_rate:.1f}% win rate)")
    
    if system_metrics and system_metrics['win_rate'] >= 60:
        report_lines.append(f"  âœ… System shows positive edge (>{system_metrics['win_rate']:.0f}% win rate)")
    elif system_metrics and system_metrics['win_rate'] >= 50:
        report_lines.append(f"  âš ï¸  System is marginally profitable ({system_metrics['win_rate']:.0f}% win rate)")
    elif system_metrics:
        report_lines.append(f"  âŒ System underperforming ({system_metrics['win_rate']:.0f}% win rate)")
    
    if system_metrics and system_metrics['sharpe_ratio'] >= 1.0:
        report_lines.append(f"  âœ… Good risk-adjusted returns (Sharpe: {system_metrics['sharpe_ratio']:.2f})")
    
    # Count exit signals
    total_exit_signals = sum(metrics['count'] for metrics in exit_results.values())
    if total_exit_signals > 0:
        avg_exit_accuracy = np.mean([m['accuracy'] for m in exit_results.values()])
        if avg_exit_accuracy >= 60:
            report_lines.append(f"  âœ… Exit signals are reliable ({avg_exit_accuracy:.0f}% accuracy)")
    
    # Statistical significance warning
    if system_metrics and system_metrics['valid_signals'] < 20:
        report_lines.append("")
        report_lines.append(f"  âš ï¸  WARNING: Limited sample size ({system_metrics['valid_signals']} signals)")
        report_lines.append(f"     Use longer period for more reliable statistics")
    
    report_lines.append("")
    report_lines.append("=" * 70)
    report_lines.append("")
    report_lines.append("ğŸ“ INTERPRETATION GUIDE:")
    report_lines.append("  â€¢ Win Rate >60% = Strong signal")
    report_lines.append("  â€¢ Expectancy >1.5% = Profitable signal")
    report_lines.append("  â€¢ Sharpe Ratio >1.0 = Good risk-adjusted returns")
    report_lines.append("  â€¢ Exit Accuracy >60% = Reliable exit timing")
    report_lines.append("")
    report_lines.append("âš ï¸  DISCLAIMER:")
    report_lines.append("  Past performance does not guarantee future results.")
    report_lines.append("  Use this analysis as one input in your trading decisions.")
    report_lines.append("")
    
    return "\n".join(report_lines)


def pair_entry_exit_signals(df: pd.DataFrame, entry_signals: List[str], 
                            exit_signals: List[str]) -> List[Dict]:
    """
    Pair each entry signal with its next exit signal and calculate returns.
    
    This function matches each entry signal occurrence with the next exit signal
    that occurs after it, calculating the actual entry-to-exit return.
    
    Args:
        df (pd.DataFrame): DataFrame with entry/exit signals and Close prices
        entry_signals (List[str]): List of entry signal column names
        exit_signals (List[str]): List of exit signal column names
        
    Returns:
        List[Dict]: List of paired trades with entry/exit info and returns
    """
    paired_trades = []
    
    # Create combined entry and exit flags
    df['Any_Entry'] = df[entry_signals].any(axis=1)
    df['Any_Exit'] = df[exit_signals].any(axis=1)
    
    # Iterate through each entry signal
    for idx in df[df['Any_Entry']].index:
        entry_date = idx
        entry_price = df.loc[idx, 'Close']
        
        # Find which specific entry signals triggered
        triggered_entries = [sig for sig in entry_signals if df.loc[idx, sig]]
        
        # Look for next exit signal after this entry
        future_data = df.loc[idx:].iloc[1:]  # Start from next day
        exit_signals_future = future_data[future_data['Any_Exit']]
        
        if len(exit_signals_future) > 0:
            # Found an exit signal
            exit_idx = exit_signals_future.index[0]
            exit_date = exit_idx
            exit_price = df.loc[exit_idx, 'Close']
            
            # Find which specific exit signals triggered
            triggered_exits = [sig for sig in exit_signals if df.loc[exit_idx, sig]]
            
            # Calculate return
            return_pct = ((exit_price - entry_price) / entry_price) * 100
            
            # Calculate holding period
            holding_days = (exit_date - entry_date).days
            
            paired_trades.append({
                'entry_date': entry_date,
                'exit_date': exit_date,
                'entry_price': entry_price,
                'exit_price': exit_price,
                'return_pct': return_pct,
                'holding_days': holding_days,
                'entry_signals': triggered_entries,
                'exit_signals': triggered_exits
            })
        else:
            # No exit signal found - trade still open or data ended
            # Calculate return to last available price
            last_price = df['Close'].iloc[-1]
            last_date = df.index[-1]
            return_pct = ((last_price - entry_price) / entry_price) * 100
            holding_days = (last_date - entry_date).days
            
            paired_trades.append({
                'entry_date': entry_date,
                'exit_date': None,
                'entry_price': entry_price,
                'exit_price': last_price,
                'return_pct': return_pct,
                'holding_days': holding_days,
                'entry_signals': triggered_entries,
                'exit_signals': ['Open Position'],
                'is_open': True
            })
    
    return paired_trades


def analyze_strategy_performance(paired_trades: List[Dict], 
                                 entry_filter: Optional[str] = None,
                                 exit_filter: Optional[str] = None) -> Dict:
    """
    Analyze performance of trades filtered by entry/exit signal type.
    
    Args:
        paired_trades (List[Dict]): List of paired entry-exit trades
        entry_filter (Optional[str]): Filter trades by specific entry signal
        exit_filter (Optional[str]): Filter trades by specific exit signal
        
    Returns:
        Dict: Performance metrics for filtered trades
    """
    # Filter trades based on criteria
    filtered_trades = paired_trades
    
    if entry_filter:
        filtered_trades = [t for t in filtered_trades 
                          if entry_filter in t['entry_signals']]
    
    if exit_filter:
        filtered_trades = [t for t in filtered_trades 
                          if exit_filter in t['exit_signals']]
    
    if len(filtered_trades) == 0:
        return {
            'total_trades': 0,
            'closed_trades': 0,
            'open_trades': 0
        }
    
    # Separate closed and open trades
    closed_trades = [t for t in filtered_trades if not t.get('is_open', False)]
    open_trades = [t for t in filtered_trades if t.get('is_open', False)]
    
    if len(closed_trades) == 0:
        return {
            'total_trades': len(filtered_trades),
            'closed_trades': 0,
            'open_trades': len(open_trades)
        }
    
    # Calculate statistics on closed trades
    returns = [t['return_pct'] for t in closed_trades]
    holding_periods = [t['holding_days'] for t in closed_trades]
    
    wins = [r for r in returns if r > 0]
    losses = [r for r in returns if r <= 0]
    
    win_rate = (len(wins) / len(returns)) * 100
    avg_return = np.mean(returns)
    median_return = np.median(returns)
    avg_win = np.mean(wins) if wins else 0
    avg_loss = np.mean(losses) if losses else 0
    avg_holding_days = np.mean(holding_periods)
    
    # Risk metrics
    profit_factor = abs(sum(wins) / sum(losses)) if losses and sum(losses) != 0 else float('inf')
    expectancy = (win_rate/100 * avg_win) + ((1-win_rate/100) * avg_loss)
    
    # Find best and worst trades
    best_trade = max(closed_trades, key=lambda x: x['return_pct'])
    worst_trade = min(closed_trades, key=lambda x: x['return_pct'])
    
    return {
        'total_trades': len(filtered_trades),
        'closed_trades': len(closed_trades),
        'open_trades': len(open_trades),
        'win_rate': win_rate,
        'wins': len(wins),
        'losses': len(losses),
        'avg_return': avg_return,
        'median_return': median_return,
        'avg_win': avg_win,
        'avg_loss': avg_loss,
        'best_return': best_trade['return_pct'],
        'worst_return': worst_trade['return_pct'],
        'best_trade_date': best_trade['entry_date'].strftime('%Y-%m-%d'),
        'worst_trade_date': worst_trade['entry_date'].strftime('%Y-%m-%d'),
        'avg_holding_days': avg_holding_days,
        'profit_factor': profit_factor,
        'expectancy': expectancy
    }


def compare_entry_strategies(paired_trades: List[Dict], entry_signals: Dict[str, str]) -> Dict:
    """
    Compare performance across different entry signal types.
    
    Args:
        paired_trades (List[Dict]): List of all paired trades
        entry_signals (Dict[str, str]): Mapping of signal column names to display names
        
    Returns:
        Dict: Comparison metrics for each entry signal type
    """
    comparison = {}
    
    for signal_col, signal_name in entry_signals.items():
        metrics = analyze_strategy_performance(paired_trades, entry_filter=signal_col)
        
        if metrics['closed_trades'] > 0:
            comparison[signal_col] = {
                'name': signal_name,
                **metrics
            }
    
    return comparison


def compare_exit_strategies(paired_trades: List[Dict], exit_signals: Dict[str, str]) -> Dict:
    """
    Compare performance across different exit signal types.
    
    Args:
        paired_trades (List[Dict]): List of all paired trades
        exit_signals (Dict[str, str]): Mapping of signal column names to display names
        
    Returns:
        Dict: Comparison metrics for each exit signal type
    """
    comparison = {}
    
    for signal_col, signal_name in exit_signals.items():
        metrics = analyze_strategy_performance(paired_trades, exit_filter=signal_col)
        
        if metrics['closed_trades'] > 0:
            comparison[signal_col] = {
                'name': signal_name,
                **metrics
            }
    
    return comparison


def generate_strategy_comparison_report(paired_trades: List[Dict], 
                                       entry_signals: Dict[str, str],
                                       exit_signals: Dict[str, str]) -> str:
    """
    Generate detailed strategy comparison report.
    
    Args:
        paired_trades (List[Dict]): List of paired entry-exit trades
        entry_signals (Dict[str, str]): Entry signal definitions
        exit_signals (Dict[str, str]): Exit signal definitions
        
    Returns:
        str: Formatted strategy comparison report
    """
    report_lines = []
    
    report_lines.append("=" * 70)
    report_lines.append("ğŸ¯ ENTRY-TO-EXIT STRATEGY ANALYSIS")
    report_lines.append("=" * 70)
    report_lines.append("")
    
    # Overall statistics
    total_trades = len(paired_trades)
    closed_trades = len([t for t in paired_trades if not t.get('is_open', False)])
    open_trades = total_trades - closed_trades
    
    report_lines.append("ğŸ“Š OVERALL TRADING STATISTICS:")
    report_lines.append(f"  Total Trades Generated: {total_trades}")
    report_lines.append(f"  Closed Trades: {closed_trades}")
    report_lines.append(f"  Open Positions: {open_trades}")
    report_lines.append("")
    
    if closed_trades == 0:
        report_lines.append("âš ï¸  No closed trades to analyze.")
        report_lines.append("   Generate more signals or use a longer time period.")
        return "\n".join(report_lines)
    
    # Entry strategy comparison
    report_lines.append("ğŸš€ ENTRY STRATEGY COMPARISON:")
    report_lines.append("")
    
    entry_comparison = compare_entry_strategies(paired_trades, entry_signals)
    
    if entry_comparison:
        # Sort by win rate
        sorted_entries = sorted(entry_comparison.items(), 
                               key=lambda x: x[1]['win_rate'], 
                               reverse=True)
        
        for signal_col, metrics in sorted_entries:
            report_lines.append(f"  {metrics['name']}:")
            report_lines.append(f"    Trades: {metrics['closed_trades']} closed, {metrics['open_trades']} open")
            report_lines.append(f"    Win Rate: {metrics['win_rate']:.1f}% ({metrics['wins']}W-{metrics['losses']}L)")
            report_lines.append(f"    Average Return: {metrics['avg_return']:+.2f}%")
            report_lines.append(f"    Median Return: {metrics['median_return']:+.2f}%")
            report_lines.append(f"    Avg Win: {metrics['avg_win']:+.2f}% | Avg Loss: {metrics['avg_loss']:+.2f}%")
            report_lines.append(f"    Best Trade: {metrics['best_trade_date']} ({metrics['best_return']:+.2f}%)")
            report_lines.append(f"    Worst Trade: {metrics['worst_trade_date']} ({metrics['worst_return']:+.2f}%)")
            report_lines.append(f"    Avg Holding Period: {metrics['avg_holding_days']:.1f} days")
            report_lines.append(f"    Profit Factor: {metrics['profit_factor']:.2f}")
            report_lines.append(f"    Expectancy: {metrics['expectancy']:+.2f}%")
            
            # Quality assessment
            if metrics['win_rate'] >= 70 and metrics['expectancy'] > 2.0:
                report_lines.append(f"    âœ… EXCELLENT - Highly profitable strategy")
            elif metrics['win_rate'] >= 60 and metrics['expectancy'] > 1.0:
                report_lines.append(f"    âœ… GOOD - Strong positive edge")
            elif metrics['win_rate'] >= 50 and metrics['expectancy'] > 0:
                report_lines.append(f"    âœ“ FAIR - Marginally profitable")
            else:
                report_lines.append(f"    âŒ POOR - Needs improvement")
            
            report_lines.append("")
    
    # Exit strategy comparison
    report_lines.append("ğŸšª EXIT STRATEGY COMPARISON:")
    report_lines.append("")
    
    exit_comparison = compare_exit_strategies(paired_trades, exit_signals)
    
    if exit_comparison:
        # Sort by win rate
        sorted_exits = sorted(exit_comparison.items(), 
                             key=lambda x: x[1]['win_rate'], 
                             reverse=True)
        
        for signal_col, metrics in sorted_exits:
            report_lines.append(f"  {metrics['name']}:")
            report_lines.append(f"    Times Used: {metrics['closed_trades']}")
            report_lines.append(f"    Win Rate: {metrics['win_rate']:.1f}% ({metrics['wins']}W-{metrics['losses']}L)")
            report_lines.append(f"    Average Return: {metrics['avg_return']:+.2f}%")
            report_lines.append(f"    Median Return: {metrics['median_return']:+.2f}%")
            report_lines.append(f"    Avg Holding Period: {metrics['avg_holding_days']:.1f} days")
            report_lines.append(f"    Profit Factor: {metrics['profit_factor']:.2f}")
            
            # Exit quality assessment
            if metrics['win_rate'] >= 70:
                report_lines.append(f"    âœ… EXCELLENT exit timing")
            elif metrics['win_rate'] >= 55:
                report_lines.append(f"    âœ“ GOOD exit timing")
            elif metrics['win_rate'] >= 45:
                report_lines.append(f"    âš ï¸  FAIR - Consider alternatives")
            else:
                report_lines.append(f"    âŒ POOR - Avoid this exit")
            
            report_lines.append("")
    
    # Best combination analysis
    report_lines.append("â­ OPTIMAL STRATEGY COMBINATIONS:")
    report_lines.append("")
    
    # Find best entry signal
    if entry_comparison:
        best_entry = max(entry_comparison.items(), 
                        key=lambda x: (x[1]['expectancy'], x[1]['win_rate']))
        report_lines.append(f"  Best Entry Signal: {best_entry[1]['name']}")
        report_lines.append(f"    Win Rate: {best_entry[1]['win_rate']:.1f}%")
        report_lines.append(f"    Expectancy: {best_entry[1]['expectancy']:+.2f}%")
        report_lines.append("")
    
    # Find best exit signal
    if exit_comparison:
        best_exit = max(exit_comparison.items(), 
                       key=lambda x: (x[1]['win_rate'], x[1]['avg_return']))
        report_lines.append(f"  Best Exit Signal: {best_exit[1]['name']}")
        report_lines.append(f"    Win Rate: {best_exit[1]['win_rate']:.1f}%")
        report_lines.append(f"    Avg Return: {best_exit[1]['avg_return']:+.2f}%")
        report_lines.append("")
    
    # Recommended strategy
    if entry_comparison and exit_comparison:
        report_lines.append("ğŸ’¡ RECOMMENDED STRATEGY:")
        report_lines.append(f"  Entry: {best_entry[1]['name']}")
        report_lines.append(f"  Exit: {best_exit[1]['name']}")
        
        # Calculate combined performance
        combined_metrics = analyze_strategy_performance(
            paired_trades, 
            entry_filter=best_entry[0],
            exit_filter=best_exit[0]
        )
        
        if combined_metrics['closed_trades'] > 0:
            report_lines.append(f"  Combined Performance:")
            report_lines.append(f"    Trades: {combined_metrics['closed_trades']}")
            report_lines.append(f"    Win Rate: {combined_metrics['win_rate']:.1f}%")
            report_lines.append(f"    Avg Return: {combined_metrics['avg_return']:+.2f}%")
            report_lines.append(f"    Expectancy: {combined_metrics['expectancy']:+.2f}%")
        
        report_lines.append("")
    
    # Statistical significance warning
    if closed_trades < 10:
        report_lines.append("âš ï¸  WARNING: Limited sample size!")
        report_lines.append(f"   Only {closed_trades} closed trades available.")
        report_lines.append("   Results may not be statistically significant.")
        report_lines.append("   Use longer time period for more reliable analysis.")
        report_lines.append("")
    
    report_lines.append("=" * 70)
    report_lines.append("")
    report_lines.append("ğŸ“ INTERPRETATION GUIDE:")
    report_lines.append("")
    report_lines.append("  Win Rate:")
    report_lines.append("    70%+ = Excellent")
    report_lines.append("    60-69% = Good")
    report_lines.append("    50-59% = Fair")
    report_lines.append("    <50% = Poor")
    report_lines.append("")
    report_lines.append("  Expectancy:")
    report_lines.append("    >2.0% = Excellent edge")
    report_lines.append("    1.0-2.0% = Good edge")
    report_lines.append("    0-1.0% = Marginal edge")
    report_lines.append("    <0% = Losing strategy")
    report_lines.append("")
    report_lines.append("  Profit Factor:")
    report_lines.append("    >2.0 = Strong system")
    report_lines.append("    1.5-2.0 = Good system")
    report_lines.append("    1.0-1.5 = Acceptable")
    report_lines.append("    <1.0 = Losing system")
    report_lines.append("")
    
    return "\n".join(report_lines)


def run_backtest(df: pd.DataFrame, ticker: str, period: str, 
                save_to_file: bool = True, output_dir: str = 'backtest_results') -> str:
    """
    Run entry-to-exit backtest analysis on signal DataFrame.
    
    Analyzes actual trading performance by pairing entry signals with their
    corresponding exit signals and calculating real returns.
    
    Args:
        df (pd.DataFrame): DataFrame with signals generated by vol_analysis.py
        ticker (str): Stock ticker symbol
        period (str): Analysis period
        save_to_file (bool): Whether to save report to file
        output_dir (str): Directory to save report (default: 'backtest_results')
        
    Returns:
        str: Entry-to-exit backtest report text
    """
    import os
    
    # Define signal mappings
    entry_signals = {
        'Strong_Buy': 'ğŸŸ¢ Strong Buy',
        'Moderate_Buy': 'ğŸŸ¡ Moderate Buy',
        'Stealth_Accumulation': 'ğŸ’ Stealth Accumulation',
        'Confluence_Signal': 'â­ Multi-Signal Confluence',
        'Volume_Breakout': 'ğŸ”¥ Volume Breakout'
    }
    
    exit_signals = {
        'Profit_Taking': 'ğŸŸ  Profit Taking',
        'Distribution_Warning': 'âš ï¸ Distribution Warning',
        'Sell_Signal': 'ğŸ”´ Sell Signal',
        'Momentum_Exhaustion': 'ğŸ’œ Momentum Exhaustion',
        'Stop_Loss': 'ğŸ›‘ Stop Loss'
    }
    
    # Generate entry-to-exit paired analysis
    paired_trades = pair_entry_exit_signals(
        df, 
        list(entry_signals.keys()), 
        list(exit_signals.keys())
    )
    
    strategy_report = generate_strategy_comparison_report(
        paired_trades, 
        entry_signals, 
        exit_signals
    )
    
    # Save to file if requested
    if save_to_file:
        # Create output directory if it doesn't exist
        os.makedirs(output_dir, exist_ok=True)
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
        # Save report
        filename = f"{ticker}_{period}_backtest_{timestamp}.txt"
        filepath = os.path.join(output_dir, filename)
        
        with open(filepath, 'w') as f:
            f.write(strategy_report)
        
        print(f"\nğŸ’¾ Backtest report saved: {filepath}")
        print(f"   ğŸ¯ Entry-to-Exit Strategy Analysis")
    
    return strategy_report


if __name__ == "__main__":
    print("This module is designed to be imported by vol_analysis.py")
    print("Use: python vol_analysis.py TICKER --backtest")
