"""
Backtesting module for volume analysis signals.

This module analyzes the historical performance of entry and exit signals
generated by the volume analysis tool.
"""

import pandas as pd
import numpy as np
from datetime import datetime
from typing import Dict, List, Tuple, Optional

from signal_metadata import get_display_name
from risk_constants import DEFAULT_TIME_STOP_BARS, DEFAULT_STOP_STRATEGY


def calculate_forward_returns(df: pd.DataFrame, periods: List[int] = [1, 10]) -> pd.DataFrame:
    """
    Calculate forward returns for different time periods.
    Note: Only used for internal calculations. Entry-to-exit analysis is preferred.
    
    Args:
        df (pd.DataFrame): DataFrame with Close prices
        periods (List[int]): List of forward periods to calculate
        
    Returns:
        pd.DataFrame: Original DataFrame with forward return columns added
    """
    df_returns = df.copy()
    
    for period in periods:
        # Calculate forward returns
        df_returns[f'Forward_Return_{period}d'] = (
            (df_returns['Close'].shift(-period) - df_returns['Close']) / df_returns['Close'] * 100
        )
    
    return df_returns


def analyze_signal_performance(df: pd.DataFrame, signal_column: str, signal_name: str, 
                               forward_periods: List[int] = [5, 20]) -> Dict:
    """
    Analyze performance of a specific signal type.
    
    Args:
        df (pd.DataFrame): DataFrame with signals and forward returns
        signal_column (str): Column name containing signal boolean flags
        signal_name (str): Human-readable name for the signal
        forward_periods (List[int]): Periods to analyze
        
    Returns:
        Dict: Performance metrics for the signal
    """
    # Get all occurrences of this signal
    signal_dates = df[df[signal_column] == True]
    
    if len(signal_dates) == 0:
        return {
            'signal_name': signal_name,
            'count': 0,
            'metrics': {}
        }
    
    metrics = {
        'signal_name': signal_name,
        'count': len(signal_dates),
        'metrics': {}
    }
    
    for period in forward_periods:
        forward_col = f'Forward_Return_{period}d'
        
        if forward_col not in signal_dates.columns:
            continue
        
        # Remove NaN values (signals near end of data)
        valid_returns = signal_dates[forward_col].dropna()
        
        if len(valid_returns) == 0:
            continue
        
        # Calculate statistics
        wins = valid_returns[valid_returns > 0]
        losses = valid_returns[valid_returns <= 0]
        
        win_rate = (len(wins) / len(valid_returns)) * 100 if len(valid_returns) > 0 else 0
        avg_return = valid_returns.mean()
        avg_win = wins.mean() if len(wins) > 0 else 0
        avg_loss = losses.mean() if len(losses) > 0 else 0
        best_return = valid_returns.max()
        worst_return = valid_returns.min()
        median_return = valid_returns.median()
        
        # Calculate expectancy
        expectancy = (win_rate/100 * avg_win) + ((1-win_rate/100) * avg_loss)
        
        # Find best and worst signals
        best_signal_idx = valid_returns.idxmax()
        worst_signal_idx = valid_returns.idxmin()
        
        metrics['metrics'][f'{period}d'] = {
            'valid_signals': len(valid_returns),
            'win_rate': win_rate,
            'wins': len(wins),
            'losses': len(losses),
            'avg_return': avg_return,
            'avg_win': avg_win,
            'avg_loss': avg_loss,
            'best_return': best_return,
            'worst_return': worst_return,
            'median_return': median_return,
            'expectancy': expectancy,
            'best_signal_date': best_signal_idx.strftime('%Y-%m-%d') if best_signal_idx else None,
            'worst_signal_date': worst_signal_idx.strftime('%Y-%m-%d') if worst_signal_idx else None
        }
    
    return metrics


def analyze_exit_signals(df: pd.DataFrame) -> Dict:
    """
    Analyze the effectiveness of exit signals.
    
    Args:
        df (pd.DataFrame): DataFrame with exit signals and forward returns
        
    Returns:
        Dict: Exit signal performance metrics
    """
    exit_signal_keys = [
        'Profit_Taking', 'Distribution_Warning', 'Sell_Signal',
        'Momentum_Exhaustion', 'Stop_Loss', 'MA_Crossdown'
    ]
    exit_signals = {key: get_display_name(key) for key in exit_signal_keys}
    
    results = {}
    
    for signal_col, signal_name in exit_signals.items():
        signal_dates = df[df[signal_col] == True]
        
        if len(signal_dates) == 0:
            continue
        
        # For exit signals, we want to see if price declined after the signal
        forward_20d = signal_dates['Forward_Return_20d'].dropna()
        
        if len(forward_20d) == 0:
            continue
        
        # Count how many times price declined after exit signal (signal was "correct")
        declines = forward_20d[forward_20d < 0]
        correct_exits = len(declines)
        
        avg_decline = forward_20d.mean()
        max_decline = forward_20d.min()
        
        results[signal_col] = {
            'signal_name': signal_name,
            'count': len(signal_dates),
            'valid_signals': len(forward_20d),
            'correct_exits': correct_exits,
            'accuracy': (correct_exits / len(forward_20d)) * 100 if len(forward_20d) > 0 else 0,
            'avg_subsequent_return': avg_decline,
            'max_decline': max_decline
        }
    
    return results


def calculate_system_metrics(df: pd.DataFrame, entry_signals: List[str]) -> Dict:
    """
    Calculate overall system performance metrics.
    
    Args:
        df (pd.DataFrame): DataFrame with all signals and returns
        entry_signals (List[str]): List of entry signal column names
        
    Returns:
        Dict: Overall system metrics
    """
    # Combine all entry signals
    df['Any_Entry_Signal'] = df[entry_signals].any(axis=1)
    
    all_signals = df[df['Any_Entry_Signal'] == True]
    
    if len(all_signals) == 0:
        return {}
    
    # Calculate returns for all signals
    forward_20d = all_signals['Forward_Return_20d'].dropna()
    
    if len(forward_20d) == 0:
        return {}
    
    wins = forward_20d[forward_20d > 0]
    losses = forward_20d[forward_20d <= 0]
    
    win_rate = (len(wins) / len(forward_20d)) * 100
    avg_return = forward_20d.mean()
    
    # Calculate Sharpe-like ratio (return / volatility)
    sharpe = avg_return / forward_20d.std() if forward_20d.std() > 0 else 0
    
    # Maximum drawdown from entry signals
    cumulative_returns = (1 + forward_20d / 100).cumprod()
    running_max = cumulative_returns.expanding().max()
    drawdown = ((cumulative_returns - running_max) / running_max) * 100
    max_drawdown = drawdown.min()
    
    return {
        'total_signals': len(all_signals),
        'valid_signals': len(forward_20d),
        'win_rate': win_rate,
        'avg_return': avg_return,
        'sharpe_ratio': sharpe,
        'max_drawdown': max_drawdown,
        'total_wins': len(wins),
        'total_losses': len(losses)
    }


def generate_backtest_report(df: pd.DataFrame, ticker: str, period: str) -> str:
    """
    Generate a comprehensive backtest report.
    
    Args:
        df (pd.DataFrame): DataFrame with signals and calculated returns
        ticker (str): Stock ticker symbol
        period (str): Analysis period
        
    Returns:
        str: Formatted backtest report
    """
    report_lines = []
    
    # Header
    report_lines.append("=" * 70)
    report_lines.append(f"üìä BACKTEST ANALYSIS FOR {ticker.upper()} ({period})")
    report_lines.append("=" * 70)
    report_lines.append("")
    
    # Entry signal definitions
    entry_signal_keys = [
        'Strong_Buy', 'Moderate_Buy', 'Stealth_Accumulation',
        'Confluence_Signal', 'Volume_Breakout'
    ]
    entry_signals = {key: get_display_name(key) for key in entry_signal_keys}
    
    # Analyze each entry signal type
    report_lines.append("üéØ ENTRY SIGNAL PERFORMANCE:")
    report_lines.append("")
    
    best_signal = None
    best_win_rate = 0
    
    for signal_col, signal_name in entry_signals.items():
        metrics = analyze_signal_performance(df, signal_col, signal_name, [5, 20])
        
        if metrics['count'] == 0:
            report_lines.append(f"  {signal_name}:")
            report_lines.append(f"    No signals generated")
            report_lines.append("")
            continue
        
        report_lines.append(f"  {signal_name}:")
        report_lines.append(f"    Total Signals: {metrics['count']}")
        
        # 5-day performance
        if '5d' in metrics['metrics']:
            m = metrics['metrics']['5d']
            report_lines.append(f"    ")
            report_lines.append(f"    5-Day Forward Returns:")
            report_lines.append(f"      Win Rate: {m['win_rate']:.1f}% ({m['wins']} wins, {m['losses']} losses)")
            report_lines.append(f"      Avg Return: {m['avg_return']:+.2f}%")
            report_lines.append(f"      Avg Win: {m['avg_win']:+.2f}% | Avg Loss: {m['avg_loss']:+.2f}%")
            report_lines.append(f"      Expectancy: {m['expectancy']:+.2f}%")
        
        # 20-day performance
        if '20d' in metrics['metrics']:
            m = metrics['metrics']['20d']
            report_lines.append(f"    ")
            report_lines.append(f"    20-Day Forward Returns:")
            report_lines.append(f"      Win Rate: {m['win_rate']:.1f}% ({m['wins']} wins, {m['losses']} losses)")
            report_lines.append(f"      Avg Return: {m['avg_return']:+.2f}%")
            report_lines.append(f"      Best Signal: {m['best_signal_date']} ({m['best_return']:+.2f}%)")
            report_lines.append(f"      Worst Signal: {m['worst_signal_date']} ({m['worst_return']:+.2f}%)")
            report_lines.append(f"      Median Return: {m['median_return']:+.2f}%")
            
            # Track best signal type
            if m['win_rate'] > best_win_rate and m['valid_signals'] >= 3:
                best_win_rate = m['win_rate']
                best_signal = signal_name
        
        report_lines.append("")
    
    # Exit signal performance
    report_lines.append("üö™ EXIT SIGNAL PERFORMANCE:")
    report_lines.append("")
    
    exit_results = analyze_exit_signals(df)
    
    if exit_results:
        for signal_col, metrics in exit_results.items():
            report_lines.append(f"  {metrics['signal_name']}:")
            report_lines.append(f"    Signals: {metrics['count']}")
            report_lines.append(f"    Correct Exits: {metrics['correct_exits']}/{metrics['valid_signals']} ({metrics['accuracy']:.1f}%)")
            report_lines.append(f"    Avg Subsequent Return: {metrics['avg_subsequent_return']:+.2f}% (20-day)")
            
            if metrics['accuracy'] >= 70:
                report_lines.append(f"    ‚úÖ Highly reliable exit indicator")
            elif metrics['accuracy'] >= 50:
                report_lines.append(f"    ‚úì Moderately reliable exit indicator")
            else:
                report_lines.append(f"    ‚ö†Ô∏è  Less reliable - use with caution")
            
            report_lines.append("")
    else:
        report_lines.append("  No exit signals generated in this period")
        report_lines.append("")
    
    # Overall system metrics
    report_lines.append("üìà OVERALL SYSTEM STATISTICS:")
    report_lines.append("")
    
    system_metrics = calculate_system_metrics(df, list(entry_signals.keys()))
    
    if system_metrics:
        report_lines.append(f"  Total Entry Signals: {system_metrics['total_signals']}")
        report_lines.append(f"  Valid for Analysis: {system_metrics['valid_signals']} (have 20-day forward data)")
        report_lines.append(f"  System Win Rate: {system_metrics['win_rate']:.1f}% ({system_metrics['total_wins']} wins, {system_metrics['total_losses']} losses)")
        report_lines.append(f"  Average Return per Signal: {system_metrics['avg_return']:+.2f}%")
        report_lines.append(f"  Risk-Adjusted Return: {system_metrics['sharpe_ratio']:.2f}")
        report_lines.append(f"  Maximum Drawdown: {system_metrics['max_drawdown']:.2f}%")
        report_lines.append("")
    
    # Key insights
    report_lines.append("üí° KEY INSIGHTS:")
    report_lines.append("")
    
    if best_signal:
        report_lines.append(f"  ‚úÖ Most Reliable Signal: {best_signal} ({best_win_rate:.1f}% win rate)")
    
    if system_metrics and system_metrics['win_rate'] >= 60:
        report_lines.append(f"  ‚úÖ System shows positive edge (>{system_metrics['win_rate']:.0f}% win rate)")
    elif system_metrics and system_metrics['win_rate'] >= 50:
        report_lines.append(f"  ‚ö†Ô∏è  System is marginally profitable ({system_metrics['win_rate']:.0f}% win rate)")
    elif system_metrics:
        report_lines.append(f"  ‚ùå System underperforming ({system_metrics['win_rate']:.0f}% win rate)")
    
    if system_metrics and system_metrics['sharpe_ratio'] >= 1.0:
        report_lines.append(f"  ‚úÖ Good risk-adjusted returns (Sharpe: {system_metrics['sharpe_ratio']:.2f})")
    
    # Count exit signals
    total_exit_signals = sum(metrics['count'] for metrics in exit_results.values())
    if total_exit_signals > 0:
        avg_exit_accuracy = np.mean([m['accuracy'] for m in exit_results.values()])
        if avg_exit_accuracy >= 60:
            report_lines.append(f"  ‚úÖ Exit signals are reliable ({avg_exit_accuracy:.0f}% accuracy)")
    
    # Statistical significance warning
    if system_metrics and system_metrics['valid_signals'] < 20:
        report_lines.append("")
        report_lines.append(f"  ‚ö†Ô∏è  WARNING: Limited sample size ({system_metrics['valid_signals']} signals)")
        report_lines.append(f"     Use longer period for more reliable statistics")
    
    report_lines.append("")
    report_lines.append("=" * 70)
    report_lines.append("")
    report_lines.append("üìù INTERPRETATION GUIDE:")
    report_lines.append("  ‚Ä¢ Win Rate >60% = Strong signal")
    report_lines.append("  ‚Ä¢ Expectancy >1.5% = Profitable signal")
    report_lines.append("  ‚Ä¢ Sharpe Ratio >1.0 = Good risk-adjusted returns")
    report_lines.append("  ‚Ä¢ Exit Accuracy >60% = Reliable exit timing")
    report_lines.append("")
    report_lines.append("‚ö†Ô∏è  DISCLAIMER:")
    report_lines.append("  Past performance does not guarantee future results.")
    report_lines.append("  Use this analysis as one input in your trading decisions.")
    report_lines.append("")
    
    return "\n".join(report_lines)


def pair_entry_exit_signals(df: pd.DataFrame, entry_signals: List[str], 
                            exit_signals: List[str]) -> List[Dict]:
    """
    Pair each entry signal with its next exit signal and calculate returns.
    
    EXECUTION TIMING (CRITICAL FIX):
    - Entry signal fires at close of day T
    - Entry executed at OPEN of day T+1 (realistic fill price)
    - Exit signal fires at close of day X  
    - Exit executed at OPEN of day X+1 (realistic fill price)
    
    This function matches each entry signal occurrence with the next exit signal
    that occurs after it, calculating the actual entry-to-exit return using
    realistic execution prices (next day opens, not same day closes).
    
    Args:
        df (pd.DataFrame): DataFrame with entry/exit signals and Next_Open prices
        entry_signals (List[str]): List of entry signal column names
        exit_signals (List[str]): List of exit signal column names
        
    Returns:
        List[Dict]: List of paired trades with entry/exit info and returns
    """
    paired_trades = []
    
    # Create combined entry and exit flags
    df['Any_Entry'] = df[entry_signals].any(axis=1)
    df['Any_Exit'] = df[exit_signals].any(axis=1)
    
    # Iterate through each entry signal
    for idx in df[df['Any_Entry']].index:
        entry_signal_date = idx
        
        # CRITICAL FIX: Entry price = OPEN of next day, not close of signal day
        # Signal fires at close of day T, we enter at open of day T+1
        if 'Next_Open' in df.columns and not pd.isna(df.loc[idx, 'Next_Open']):
            entry_price = df.loc[idx, 'Next_Open']  # ‚úÖ Realistic entry price
            
            # Calculate actual entry date (day after signal)
            entry_idx_pos = df.index.get_loc(idx)
            if entry_idx_pos + 1 < len(df):
                actual_entry_date = df.index[entry_idx_pos + 1]
            else:
                # No next day data available - skip this signal
                continue
        else:
            # Fallback if Next_Open not available - skip to avoid lookahead
            continue
        
        # Find which specific entry signals triggered
        triggered_entries = [sig for sig in entry_signals if df.loc[idx, sig]]
        
        # Look for next exit signal after this entry
        future_data = df.loc[idx:].iloc[1:]  # Start from next day after signal
        exit_signals_future = future_data[future_data['Any_Exit']]
        
        if len(exit_signals_future) > 0:
            # Found an exit signal
            exit_signal_idx = exit_signals_future.index[0]
            exit_signal_date = exit_signal_idx
            
            # CRITICAL FIX: Exit price = OPEN of day after exit signal
            # Exit signal fires at close of day X, we exit at open of day X+1
            if 'Next_Open' in df.columns and not pd.isna(df.loc[exit_signal_idx, 'Next_Open']):
                exit_price = df.loc[exit_signal_idx, 'Next_Open']  # ‚úÖ Realistic exit price
                
                # Calculate actual exit date (day after exit signal)
                exit_idx_pos = df.index.get_loc(exit_signal_idx)
                if exit_idx_pos + 1 < len(df):
                    actual_exit_date = df.index[exit_idx_pos + 1]
                else:
                    # No next day data - use last available price as emergency exit
                    exit_price = df.loc[exit_signal_idx, 'Close']
                    actual_exit_date = exit_signal_date
            else:
                # Fallback if Next_Open not available - use signal day close
                exit_price = df.loc[exit_signal_idx, 'Close']
                actual_exit_date = exit_signal_date
            
            # Find which specific exit signals triggered
            triggered_exits = [sig for sig in exit_signals if df.loc[exit_signal_idx, sig]]
            
            # Calculate return using realistic entry/exit prices
            return_pct = ((exit_price - entry_price) / entry_price) * 100
            
            # Calculate holding period
            holding_days = (actual_exit_date - actual_entry_date).days
            
            paired_trades.append({
                'entry_signal_date': entry_signal_date,  # When signal fired
                'entry_date': actual_entry_date,         # When you actually entered
                'exit_signal_date': exit_signal_date,    # When exit signal fired
                'exit_date': actual_exit_date,           # When you actually exited
                'entry_price': entry_price,              # Realistic fill price
                'exit_price': exit_price,                # Realistic fill price
                'return_pct': return_pct,
                'holding_days': holding_days,
                'entry_signals': triggered_entries,
                'exit_signals': triggered_exits
            })
        else:
            # No exit signal found - trade still open or data ended
            # Calculate return to last available price
            last_price = df['Close'].iloc[-1]
            last_date = df.index[-1]
            return_pct = ((last_price - entry_price) / entry_price) * 100
            holding_days = (last_date - actual_entry_date).days
            
            paired_trades.append({
                'entry_signal_date': entry_signal_date,
                'entry_date': actual_entry_date,
                'exit_signal_date': None,
                'exit_date': None,
                'entry_price': entry_price,
                'exit_price': last_price,
                'return_pct': return_pct,
                'holding_days': holding_days,
                'entry_signals': triggered_entries,
                'exit_signals': ['Open Position'],
                'is_open': True
            })
    
    return paired_trades


def analyze_strategy_performance(paired_trades: List[Dict], 
                                 entry_filter: Optional[str] = None,
                                 exit_filter: Optional[str] = None) -> Dict:
    """
    Analyze performance of trades filtered by entry/exit signal type.
    
    Args:
        paired_trades (List[Dict]): List of paired entry-exit trades
        entry_filter (Optional[str]): Filter trades by specific entry signal
        exit_filter (Optional[str]): Filter trades by specific exit signal
        
    Returns:
        Dict: Performance metrics for filtered trades
    """
    # Filter trades based on criteria
    filtered_trades = paired_trades
    
    if entry_filter:
        filtered_trades = [
            t for t in filtered_trades 
            if entry_filter in t.get('entry_signals', [])
        ]
    
    if exit_filter:
        filtered_trades = [
            t for t in filtered_trades 
            if exit_filter in t.get('exit_signals', [])
        ]
    
    if len(filtered_trades) == 0:
        return {
            'total_trades': 0,
            'closed_trades': 0,
            'open_trades': 0
        }
    
    # Separate closed and open trades
    closed_trades = [t for t in filtered_trades if not t.get('is_open', False)]
    open_trades = [t for t in filtered_trades if t.get('is_open', False)]
    
    if len(closed_trades) == 0:
        return {
            'total_trades': len(filtered_trades),
            'closed_trades': 0,
            'open_trades': len(open_trades)
        }
    
    # Calculate statistics on closed trades
    returns = [t['return_pct'] for t in closed_trades]
    holding_periods = [t['holding_days'] for t in closed_trades]
    
    wins = [r for r in returns if r > 0]
    losses = [r for r in returns if r <= 0]
    
    win_rate = (len(wins) / len(returns)) * 100
    avg_return = np.mean(returns)
    median_return = np.median(returns)
    avg_win = np.mean(wins) if wins else 0
    avg_loss = np.mean(losses) if losses else 0
    avg_holding_days = np.mean(holding_periods)
    
    # Risk metrics
    profit_factor = abs(sum(wins) / sum(losses)) if losses and sum(losses) != 0 else float('inf')
    expectancy = (win_rate/100 * avg_win) + ((1-win_rate/100) * avg_loss)
    
    # Find best and worst trades
    best_trade = max(closed_trades, key=lambda x: x['return_pct'])
    worst_trade = min(closed_trades, key=lambda x: x['return_pct'])
    
    return {
        'total_trades': len(filtered_trades),
        'closed_trades': len(closed_trades),
        'open_trades': len(open_trades),
        'win_rate': win_rate,
        'wins': len(wins),
        'losses': len(losses),
        'avg_return': avg_return,
        'median_return': median_return,
        'avg_win': avg_win,
        'avg_loss': avg_loss,
        'best_return': best_trade['return_pct'],
        'worst_return': worst_trade['return_pct'],
        'best_trade_date': best_trade['entry_date'].strftime('%Y-%m-%d'),
        'worst_trade_date': worst_trade['entry_date'].strftime('%Y-%m-%d'),
        'best_trade_ticker': best_trade.get('ticker', 'N/A'),
        'worst_trade_ticker': worst_trade.get('ticker', 'N/A'),
        'avg_holding_days': avg_holding_days,
        'profit_factor': profit_factor,
        'expectancy': expectancy
    }


def compare_entry_strategies(paired_trades: List[Dict], entry_signals: Dict[str, str]) -> Dict:
    """
    Compare performance across different entry signal types.
    
    Args:
        paired_trades (List[Dict]): List of all paired trades
        entry_signals (Dict[str, str]): Mapping of signal column names to display names
        
    Returns:
        Dict: Comparison metrics for each entry signal type
    """
    comparison = {}
    
    for signal_col, signal_name in entry_signals.items():
        metrics = analyze_strategy_performance(paired_trades, entry_filter=signal_col)
        
        if metrics['closed_trades'] > 0:
            comparison[signal_col] = {
                'name': signal_name,
                **metrics
            }
    
    return comparison


def compare_exit_strategies(paired_trades: List[Dict], exit_signals: Dict[str, str]) -> Dict:
    """
    Compare performance across different exit signal types.
    
    Args:
        paired_trades (List[Dict]): List of all paired trades
        exit_signals (Dict[str, str]): Mapping of signal column names to display names
        
    Returns:
        Dict: Comparison metrics for each exit signal type
    """
    comparison = {}
    
    for signal_col, signal_name in exit_signals.items():
        metrics = analyze_strategy_performance(paired_trades, exit_filter=signal_col)
        
        if metrics['closed_trades'] > 0:
            comparison[signal_col] = {
                'name': signal_name,
                **metrics
            }
    
    return comparison


def generate_strategy_comparison_report(paired_trades: List[Dict], 
                                       entry_signals: Dict[str, str],
                                       exit_signals: Dict[str, str]) -> str:
    """
    Generate detailed strategy comparison report.
    
    Args:
        paired_trades (List[Dict]): List of paired entry-exit trades
        entry_signals (Dict[str, str]): Entry signal definitions
        exit_signals (Dict[str, str]): Exit signal definitions
        
    Returns:
        str: Formatted strategy comparison report
    """
    report_lines = []
    
    report_lines.append("=" * 70)
    report_lines.append("üéØ ENTRY-TO-EXIT STRATEGY ANALYSIS")
    report_lines.append("=" * 70)
    report_lines.append("")
    
    # Overall statistics
    total_trades = len(paired_trades)
    closed_trades = len([t for t in paired_trades if not t.get('is_open', False)])
    open_trades = total_trades - closed_trades
    
    report_lines.append("üìä OVERALL TRADING STATISTICS:")
    report_lines.append(f"  Total Trades Generated: {total_trades}")
    report_lines.append(f"  Closed Trades: {closed_trades}")
    report_lines.append(f"  Open Positions: {open_trades}")
    report_lines.append("")
    
    if closed_trades == 0:
        report_lines.append("‚ö†Ô∏è  No closed trades to analyze.")
        report_lines.append("   Generate more signals or use a longer time period.")
        return "\n".join(report_lines)
    
    # Entry strategy comparison
    report_lines.append("üöÄ ENTRY STRATEGY COMPARISON:")
    report_lines.append("")
    
    entry_comparison = compare_entry_strategies(paired_trades, entry_signals)
    
    if entry_comparison:
        # Sort by win rate
        sorted_entries = sorted(entry_comparison.items(), 
                               key=lambda x: x[1]['win_rate'], 
                               reverse=True)
        
        for signal_col, metrics in sorted_entries:
            report_lines.append(f"  {metrics['name']}:")
            report_lines.append(f"    Trades: {metrics['closed_trades']} closed, {metrics['open_trades']} open")
            report_lines.append(f"    Win Rate: {metrics['win_rate']:.1f}% ({metrics['wins']}W-{metrics['losses']}L)")
            report_lines.append(f"    Average Return: {metrics['avg_return']:+.2f}%")
            report_lines.append(f"    Median Return: {metrics['median_return']:+.2f}%")
            report_lines.append(f"    Avg Win: {metrics['avg_win']:+.2f}% | Avg Loss: {metrics['avg_loss']:+.2f}%")
            report_lines.append(f"    Best Trade: {metrics['best_trade_date']} ({metrics['best_return']:+.2f}%)")
            report_lines.append(f"    Worst Trade: {metrics['worst_trade_date']} ({metrics['worst_return']:+.2f}%)")
            report_lines.append(f"    Avg Holding Period: {metrics['avg_holding_days']:.1f} days")
            report_lines.append(f"    Profit Factor: {metrics['profit_factor']:.2f}")
            report_lines.append(f"    Expectancy: {metrics['expectancy']:+.2f}%")
            
            # Quality assessment
            if metrics['win_rate'] >= 70 and metrics['expectancy'] > 2.0:
                report_lines.append(f"    ‚úÖ EXCELLENT - Highly profitable strategy")
            elif metrics['win_rate'] >= 60 and metrics['expectancy'] > 1.0:
                report_lines.append(f"    ‚úÖ GOOD - Strong positive edge")
            elif metrics['win_rate'] >= 50 and metrics['expectancy'] > 0:
                report_lines.append(f"    ‚úì FAIR - Marginally profitable")
            else:
                report_lines.append(f"    ‚ùå POOR - Needs improvement")
            
            report_lines.append("")
    
    # Exit strategy comparison
    report_lines.append("üö™ EXIT STRATEGY COMPARISON:")
    report_lines.append("")
    
    exit_comparison = compare_exit_strategies(paired_trades, exit_signals)
    
    if exit_comparison:
        # Sort by win rate
        sorted_exits = sorted(exit_comparison.items(), 
                             key=lambda x: x[1]['win_rate'], 
                             reverse=True)
        
        for signal_col, metrics in sorted_exits:
            report_lines.append(f"  {metrics['name']}:")
            report_lines.append(f"    Times Used: {metrics['closed_trades']}")
            report_lines.append(f"    Win Rate: {metrics['win_rate']:.1f}% ({metrics['wins']}W-{metrics['losses']}L)")
            report_lines.append(f"    Average Return: {metrics['avg_return']:+.2f}%")
            report_lines.append(f"    Median Return: {metrics['median_return']:+.2f}%")
            report_lines.append(f"    Avg Holding Period: {metrics['avg_holding_days']:.1f} days")
            report_lines.append(f"    Profit Factor: {metrics['profit_factor']:.2f}")
            
            # Exit quality assessment
            if metrics['win_rate'] >= 70:
                report_lines.append(f"    ‚úÖ EXCELLENT exit timing")
            elif metrics['win_rate'] >= 55:
                report_lines.append(f"    ‚úì GOOD exit timing")
            elif metrics['win_rate'] >= 45:
                report_lines.append(f"    ‚ö†Ô∏è  FAIR - Consider alternatives")
            else:
                report_lines.append(f"    ‚ùå POOR - Avoid this exit")
            
            report_lines.append("")
    
    # Best combination analysis
    report_lines.append("‚≠ê OPTIMAL STRATEGY COMBINATIONS:")
    report_lines.append("")
    
    # Find best entry signal
    if entry_comparison:
        best_entry = max(entry_comparison.items(), 
                        key=lambda x: (x[1]['expectancy'], x[1]['win_rate']))
        report_lines.append(f"  Best Entry Signal: {best_entry[1]['name']}")
        report_lines.append(f"    Win Rate: {best_entry[1]['win_rate']:.1f}%")
        report_lines.append(f"    Expectancy: {best_entry[1]['expectancy']:+.2f}%")
        report_lines.append("")
    
    # Find best exit signal
    if exit_comparison:
        best_exit = max(exit_comparison.items(), 
                       key=lambda x: (x[1]['win_rate'], x[1]['avg_return']))
        report_lines.append(f"  Best Exit Signal: {best_exit[1]['name']}")
        report_lines.append(f"    Win Rate: {best_exit[1]['win_rate']:.1f}%")
        report_lines.append(f"    Avg Return: {best_exit[1]['avg_return']:+.2f}%")
        report_lines.append("")
    
    # Recommended strategy
    if entry_comparison and exit_comparison:
        report_lines.append("üí° RECOMMENDED STRATEGY:")
        report_lines.append(f"  Entry: {best_entry[1]['name']}")
        report_lines.append(f"  Exit: {best_exit[1]['name']}")
        
        # Calculate combined performance
        combined_metrics = analyze_strategy_performance(
            paired_trades, 
            entry_filter=best_entry[0],
            exit_filter=best_exit[0]
        )
        
        if combined_metrics['closed_trades'] > 0:
            report_lines.append(f"  Combined Performance:")
            report_lines.append(f"    Trades: {combined_metrics['closed_trades']}")
            report_lines.append(f"    Win Rate: {combined_metrics['win_rate']:.1f}%")
            report_lines.append(f"    Avg Return: {combined_metrics['avg_return']:+.2f}%")
            report_lines.append(f"    Expectancy: {combined_metrics['expectancy']:+.2f}%")
        
        report_lines.append("")
    
    # Statistical significance warning
    if closed_trades < 10:
        report_lines.append("‚ö†Ô∏è  WARNING: Limited sample size!")
        report_lines.append(f"   Only {closed_trades} closed trades available.")
        report_lines.append("   Results may not be statistically significant.")
        report_lines.append("   Use longer time period for more reliable analysis.")
        report_lines.append("")
    
    report_lines.append("=" * 70)
    report_lines.append("")
    report_lines.append("üìù INTERPRETATION GUIDE:")
    report_lines.append("")
    report_lines.append("  Win Rate:")
    report_lines.append("    70%+ = Excellent")
    report_lines.append("    60-69% = Good")
    report_lines.append("    50-59% = Fair")
    report_lines.append("    <50% = Poor")
    report_lines.append("")
    report_lines.append("  Expectancy:")
    report_lines.append("    >2.0% = Excellent edge")
    report_lines.append("    1.0-2.0% = Good edge")
    report_lines.append("    0-1.0% = Marginal edge")
    report_lines.append("    <0% = Losing strategy")
    report_lines.append("")
    report_lines.append("  Profit Factor:")
    report_lines.append("    >2.0 = Strong system")
    report_lines.append("    1.5-2.0 = Good system")
    report_lines.append("    1.0-1.5 = Acceptable")
    report_lines.append("    <1.0 = Losing system")
    report_lines.append("")
    
    return "\n".join(report_lines)


def run_backtest(df: pd.DataFrame, ticker: str, period: str, 
                save_to_file: bool = True, output_dir: str = 'backtest_results') -> str:
    """
    Run entry-to-exit backtest analysis on signal DataFrame.
    
    Analyzes actual trading performance by pairing entry signals with their
    corresponding exit signals and calculating real returns.
    
    Args:
        df (pd.DataFrame): DataFrame with signals generated by vol_analysis.py
        ticker (str): Stock ticker symbol
        period (str): Analysis period
        save_to_file (bool): Whether to save report to file
        output_dir (str): Directory to save report (default: 'backtest_results')
        
    Returns:
        str: Entry-to-exit backtest report text
    """
    import os
    
    # Define signal mappings
    entry_signal_keys = [
        'Strong_Buy', 'Moderate_Buy', 'Stealth_Accumulation', 'Confluence_Signal', 'Volume_Breakout'
    ]
    exit_signal_keys = [
        'Profit_Taking', 'Distribution_Warning', 'Sell_Signal', 'Momentum_Exhaustion', 'Stop_Loss', 'MA_Crossdown'
    ]
    entry_signals = {key: get_display_name(key) for key in entry_signal_keys}
    exit_signals = {key: get_display_name(key) for key in exit_signal_keys}
    
    # Generate entry-to-exit paired analysis
    paired_trades = pair_entry_exit_signals(
        df, 
        list(entry_signals.keys()), 
        list(exit_signals.keys())
    )
    
    strategy_report = generate_strategy_comparison_report(
        paired_trades, 
        entry_signals, 
        exit_signals
    )
    
    # Save to file if requested
    if save_to_file:
        # Create output directory if it doesn't exist
        os.makedirs(output_dir, exist_ok=True)
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
        # Save report
        filename = f"{ticker}_{period}_backtest_{timestamp}.txt"
        filepath = os.path.join(output_dir, filename)
        
        with open(filepath, 'w') as f:
            f.write(strategy_report)
        
        print(f"\nüíæ Backtest report saved: {filepath}")
        print(f"   üéØ Entry-to-Exit Strategy Analysis")
    
    return strategy_report


def optimize_signal_thresholds(df: pd.DataFrame, signal_col: str, score_col: str, 
                              signal_name: str = None, thresholds: List[float] = None) -> Dict:
    """
    Test different score thresholds and measure trading performance at each level.
    
    This function enables empirical threshold optimization by:
    1. Filtering trades to only those meeting each threshold
    2. Running entry-to-exit analysis on filtered trades
    3. Measuring win rate, expectancy, and sample size
    4. Finding optimal threshold that balances performance and sample size
    
    Args:
        df: DataFrame with signals, scores, and Next_Open prices
        signal_col: Column name for boolean signal (e.g., 'Moderate_Buy')
        score_col: Column name for signal score (e.g., 'Moderate_Buy_Score')
        signal_name: Human-readable name for reporting
        thresholds: List of threshold values to test (default: [0,4,5,6,7,8,9])
        
    Returns:
        Dict: Results mapping threshold ‚Üí {win_rate, expectancy, trades, etc.}
    """
    if thresholds is None:
        thresholds = [0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]
    
    if signal_name is None:
        signal_name = signal_col
    
    results = {}
    
    for threshold in thresholds:
        # Create a filtered signal that only triggers when score >= threshold
        df_filtered = df.copy()
        df_filtered[f'{signal_col}_filtered'] = (
            (df[signal_col] == True) & 
            (df[score_col] >= threshold)
        )
        
        # Skip if no signals at this threshold
        if df_filtered[f'{signal_col}_filtered'].sum() == 0:
            results[threshold] = {
                'threshold': threshold,
                'trades': 0,
                'win_rate': 0,
                'avg_return': 0,
                'expectancy': 0,
                'sample_size': 0
            }
            continue
        
        # Run backtest analysis on filtered signals
        try:
            # Use existing pair_entry_exit_signals with filtered signal
            exit_signals = ['Profit_Taking', 'Distribution_Warning', 'Sell_Signal',
                           'Momentum_Exhaustion', 'Stop_Loss', 'MA_Crossdown']
            
            # Pair filtered entry signals with exit signals
            paired_trades = pair_entry_exit_signals(
                df_filtered, 
                [f'{signal_col}_filtered'], 
                exit_signals
            )
            
            if not paired_trades:
                results[threshold] = {
                    'threshold': threshold,
                    'trades': 0,
                    'win_rate': 0,
                    'avg_return': 0,
                    'expectancy': 0,
                    'sample_size': 0
                }
                continue
            
            # Analyze performance using existing function
            metrics = analyze_strategy_performance(paired_trades, 
                                                  entry_filter=f'{signal_col}_filtered')
            
            # Extract key metrics
            results[threshold] = {
                'threshold': threshold,
                'trades': metrics.get('closed_trades', 0),
                'win_rate': metrics.get('win_rate', 0),
                'avg_return': metrics.get('avg_return', 0),
                'expectancy': metrics.get('expectancy', 0),
                'sample_size': metrics.get('total_trades', 0),
                'profit_factor': metrics.get('profit_factor', 0),
                'best_return': metrics.get('best_return', 0),
                'worst_return': metrics.get('worst_return', 0)
            }
            
        except Exception as e:
            # Handle any errors gracefully
            results[threshold] = {
                'threshold': threshold,
                'trades': 0,
                'win_rate': 0,
                'avg_return': 0,
                'expectancy': 0,
                'sample_size': 0,
                'error': str(e)
            }
    
    return results


def generate_threshold_optimization_report(optimization_results: Dict, signal_name: str, 
                                          ticker: str, period: str) -> str:
    """
    Generate formatted threshold optimization report.
    
    Args:
        optimization_results: Results from optimize_signal_thresholds()
        signal_name: Human-readable signal name
        ticker: Stock ticker symbol
        period: Analysis period
        
    Returns:
        str: Formatted optimization report
    """
    report_lines = []
    
    report_lines.append("=" * 70)
    report_lines.append(f"üìä THRESHOLD OPTIMIZATION: {signal_name.upper()}")
    report_lines.append(f"Ticker: {ticker} | Period: {period}")
    report_lines.append("=" * 70)
    report_lines.append("")
    
    # Sort results by threshold
    sorted_results = sorted(optimization_results.items(), key=lambda x: x[0])
    
    # Table header
    report_lines.append(f"{'Threshold':<10} {'Trades':<7} {'Win Rate':<10} {'Avg Return':<12} {'Expectancy':<12} {'P.Factor':<10}")
    report_lines.append("-" * 70)
    
    best_expectancy = -999
    best_threshold = None
    
    for threshold, metrics in sorted_results:
        trades = metrics['trades']
        win_rate = metrics['win_rate']
        avg_return = metrics['avg_return']
        expectancy = metrics['expectancy']
        profit_factor = metrics.get('profit_factor', 0)
        
        # Format the row
        report_lines.append(f"‚â•{threshold:<9.1f} {trades:<7} {win_rate:<10.1f}% {avg_return:<+12.2f}% {expectancy:<+12.2f}% {profit_factor:<10.2f}")
        
        # Track best performance (minimum 10 trades for reliability)
        if trades >= 10 and expectancy > best_expectancy:
            best_expectancy = expectancy
            best_threshold = threshold
    
    report_lines.append("")
    
    # Recommendation
    if best_threshold is not None:
        best_metrics = optimization_results[best_threshold]
        report_lines.append("üí° RECOMMENDED THRESHOLD:")
        report_lines.append(f"  Use threshold ‚â•{best_threshold:.1f}")
        report_lines.append(f"  ‚Ä¢ Win Rate: {best_metrics['win_rate']:.1f}%")
        report_lines.append(f"  ‚Ä¢ Expectancy: {best_metrics['expectancy']:+.2f}%")
        report_lines.append(f"  ‚Ä¢ Sample Size: {best_metrics['trades']} trades")
        report_lines.append(f"  ‚Ä¢ Profit Factor: {best_metrics.get('profit_factor', 0):.2f}")
        report_lines.append("")
        
        # Quality assessment
        if best_metrics['expectancy'] > 2.0 and best_metrics['win_rate'] > 60:
            report_lines.append("‚úÖ EXCELLENT - Strong edge with good reliability")
        elif best_metrics['expectancy'] > 1.0 and best_metrics['win_rate'] > 55:
            report_lines.append("‚úÖ GOOD - Solid positive edge")
        elif best_metrics['expectancy'] > 0 and best_metrics['win_rate'] > 50:
            report_lines.append("‚úì FAIR - Marginal positive edge")
        else:
            report_lines.append("‚ö†Ô∏è POOR - Consider alternative thresholds or signal improvements")
    else:
        report_lines.append("‚ö†Ô∏è NO RELIABLE THRESHOLD FOUND")
        report_lines.append("  ‚Ä¢ All thresholds had <10 trades (insufficient sample)")
        report_lines.append("  ‚Ä¢ Consider using longer time period or lower thresholds")
    
    report_lines.append("")
    
    # Sample size warnings
    insufficient_samples = [t for t, m in sorted_results if m['trades'] > 0 and m['trades'] < 10]
    if insufficient_samples:
        report_lines.append("‚ö†Ô∏è SAMPLE SIZE WARNINGS:")
        for threshold in insufficient_samples:
            metrics = optimization_results[threshold]
            report_lines.append(f"  ‚Ä¢ Threshold ‚â•{threshold:.1f}: Only {metrics['trades']} trades (need ‚â•10)")
        report_lines.append("")
    
    # Usage guide
    report_lines.append("üìù INTERPRETATION GUIDE:")
    report_lines.append("  ‚Ä¢ Expectancy >2.0% = Excellent edge")
    report_lines.append("  ‚Ä¢ Expectancy 1.0-2.0% = Good edge")
    report_lines.append("  ‚Ä¢ Expectancy 0-1.0% = Marginal edge")
    report_lines.append("  ‚Ä¢ Win Rate >60% = Strong")
    report_lines.append("  ‚Ä¢ Profit Factor >2.0 = Excellent")
    report_lines.append("  ‚Ä¢ Sample Size ‚â•20 preferred for reliability")
    report_lines.append("")
    
    return "\n".join(report_lines)


def run_full_threshold_optimization(df: pd.DataFrame, ticker: str, period: str, 
                                   save_to_file: bool = True, output_dir: str = 'backtest_results') -> str:
    """
    Run threshold optimization for all major signal types.
    
    Args:
        df: DataFrame with signals and scores
        ticker: Stock ticker symbol
        period: Analysis period
        save_to_file: Whether to save report to file
        output_dir: Directory to save report
        
    Returns:
        str: Complete threshold optimization report
    """
    import os
    
    # Define signals to optimize
    signals_to_optimize = [
        ('Moderate_Buy', 'Moderate_Buy_Score', 'Moderate Buy'),
        ('Profit_Taking', 'Profit_Taking_Score', 'Profit Taking'),
        ('Stealth_Accumulation', 'Stealth_Accumulation_Score', 'Stealth Accumulation')
    ]
    
    full_report_lines = []
    full_report_lines.append("=" * 80)
    full_report_lines.append(f"üéØ COMPLETE THRESHOLD OPTIMIZATION ANALYSIS")
    full_report_lines.append(f"Ticker: {ticker} | Period: {period}")
    full_report_lines.append(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    full_report_lines.append("=" * 80)
    full_report_lines.append("")
    
    recommended_thresholds = {}
    
    for signal_col, score_col, signal_name in signals_to_optimize:
        if signal_col not in df.columns or score_col not in df.columns:
            full_report_lines.append(f"‚ö†Ô∏è Skipping {signal_name}: Missing columns")
            full_report_lines.append("")
            continue
        
        print(f"  Optimizing {signal_name}...")
        
        # Run optimization for this signal
        results = optimize_signal_thresholds(df, signal_col, score_col, signal_name)
        
        # Generate individual report
        signal_report = generate_threshold_optimization_report(results, signal_name, ticker, period)
        full_report_lines.append(signal_report)
        full_report_lines.append("")
        
        # Extract recommendation for summary
        valid_results = {t: m for t, m in results.items() if m['trades'] >= 10}
        if valid_results:
            best_threshold = max(valid_results.items(), key=lambda x: x[1]['expectancy'])
            recommended_thresholds[signal_name] = {
                'threshold': best_threshold[0],
                'metrics': best_threshold[1]
            }
    
    # Summary of recommendations
    full_report_lines.append("üéØ THRESHOLD RECOMMENDATIONS SUMMARY:")
    full_report_lines.append("=" * 50)
    
    if recommended_thresholds:
        for signal_name, rec in recommended_thresholds.items():
            threshold = rec['threshold']
            metrics = rec['metrics']
            full_report_lines.append(f"{signal_name}:")
            full_report_lines.append(f"  Threshold: ‚â•{threshold:.1f}")
            full_report_lines.append(f"  Win Rate: {metrics['win_rate']:.1f}%")
            full_report_lines.append(f"  Expectancy: {metrics['expectancy']:+.2f}%")
            full_report_lines.append(f"  Sample: {metrics['trades']} trades")
            full_report_lines.append("")
    else:
        full_report_lines.append("‚ö†Ô∏è No reliable thresholds found.")
        full_report_lines.append("Consider using longer time period or reviewing signal logic.")
        full_report_lines.append("")
    
    # Save to file if requested
    full_report = "\n".join(full_report_lines)
    
    if save_to_file:
        os.makedirs(output_dir, exist_ok=True)
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"{ticker}_{period}_threshold_optimization_{timestamp}.txt"
        filepath = os.path.join(output_dir, filename)
        
        with open(filepath, 'w') as f:
            f.write(full_report)
        
        print(f"  üíæ Optimization report saved: {filename}")
    
    return full_report


def run_risk_managed_backtest(
    df: pd.DataFrame, 
    ticker: str, 
    account_value: float = 100000,
    risk_pct: float = 0.75,
    stop_strategy: str = DEFAULT_STOP_STRATEGY,
    time_stop_bars: int = DEFAULT_TIME_STOP_BARS,
    transaction_costs: Optional[Dict] = None,
    save_to_file: bool = True,
    output_dir: str = 'backtest_results',
    verbose: bool = True
) -> Dict:
    """
    Run backtest using RiskManager for position management and exit logic.
    
    This implements Item #5: P&L-Aware Exit Logic by using the RiskManager class
    to handle:
    - Risk-based position sizing (0.5-1% per trade)
    - Initial stop placement: min(swing_low - 0.5*ATR, VWAP - 1*ATR)
    - Time stops after 12 bars if <+1R
    - Momentum failure exits (CMF <0 OR close < VWAP)
    - Profit scaling at +2R with trailing stops
    
    Args:
        df: DataFrame with signals and indicators from vol_analysis.py
        ticker: Stock symbol
        account_value: Starting account value for position sizing
        risk_pct: Risk percentage per trade (0.5-1.0% recommended)
        stop_strategy: Stop-loss strategy (static, vol_regime, atr_dynamic, pct_trail, time_decay)
        save_to_file: Whether to save report to file
        output_dir: Directory to save reports
        
    Returns:
        Dict with trades, risk_manager, and performance summary
        
    Raises:
        ImportError: If risk_manager module not available
    """
    import os
    try:
        from risk_manager import RiskManager, analyze_risk_managed_trades
    except ImportError:
        raise ImportError("risk_manager module required for risk-managed backtesting")
    
    # PERFORMANCE OPTIMIZATION: Pre-compute regime data
    # Add regime columns to DataFrame BEFORE backtest loop to eliminate API calls
    from regime_filter import add_regime_columns_to_df
    df = add_regime_columns_to_df(df, ticker)
    
    # Initialize RiskManager
    risk_mgr = RiskManager(
        account_value=account_value,
        risk_pct_per_trade=risk_pct,
        stop_strategy=stop_strategy,
        time_stop_bars=time_stop_bars,
        transaction_costs=transaction_costs
    )
    
    if verbose:
        print(f"\nüéØ RISK-MANAGED BACKTEST: {ticker}")
        print(f"   Starting Account Value: ${account_value:,.0f}")
        print(f"   Risk Per Trade: {risk_pct}%")
        print(f"   Stop Strategy: {stop_strategy}")
        print("="*70)
    
    # Entry and exit signal columns to monitor
    entry_signals = ['Strong_Buy', 'Moderate_Buy', 'Stealth_Accumulation', 
                     'Confluence_Signal', 'Volume_Breakout']
    
    exit_signals = ['Profit_Taking', 'Distribution_Warning', 'Sell_Signal',
                    'Momentum_Exhaustion', 'Stop_Loss', 'MA_Crossdown']
    
    # Track all trades with sequential transaction numbers
    all_trades = []
    transaction_number = 1  # Sequential transaction ID for ordering
    
    # Iterate through DataFrame
    for idx in range(len(df)):
        current_date = df.index[idx]
        current_price = df.iloc[idx]['Close']
        
        # Update active positions FIRST (before checking for new entries)
        if ticker in risk_mgr.active_positions:
            # Check risk management rules (hard stops, time stops, profit scaling)
            exit_check = risk_mgr.update_position(
                ticker=ticker,
                current_date=current_date,
                current_price=current_price,
                df=df,
                current_idx=idx
            )
            
            # Check for regular exit signals (proven exit system)
            has_exit_signal = any(df.iloc[idx][sig] for sig in exit_signals)
            triggered_exits = [sig for sig in exit_signals if df.iloc[idx][sig]]
            
            # Exit if EITHER risk management OR regular exit signal triggers
            should_exit_risk_mgmt = exit_check['should_exit']
            should_exit_signal = has_exit_signal
            
            if should_exit_risk_mgmt or should_exit_signal:
                # Determine exit type, reason, and capture exit signals
                if should_exit_risk_mgmt:
                    exit_type = exit_check['exit_type']
                    exit_reason = exit_check['reason']
                    # For risk management exits, no specific exit signals triggered
                    exit_signals_list = []
                else:
                    # Regular exit signal - use the first one that triggered
                    exit_type = 'SIGNAL_EXIT'
                    exit_reason = f"Exit signal: {', '.join(triggered_exits)}"
                    exit_check['exit_type'] = exit_type
                    exit_check['reason'] = exit_reason
                    exit_check['should_exit'] = True
                    # Store the actual exit signals that triggered
                    exit_signals_list = triggered_exits
                
                # Add exit signals to exit_check for passing to close_position
                exit_check['exit_signals'] = exit_signals_list
                
                # Close position (use current price for signal exits)
                exit_date = current_date
                exit_price = current_price if should_exit_signal else exit_check['exit_price']
                
                # For partial exits, just record the trade but keep position open
                trade = risk_mgr.close_position(
                    ticker=ticker,
                    exit_price=exit_price,
                    exit_type=exit_check['exit_type'],
                    exit_date=exit_date,
                    partial_exit_pct=exit_check.get('exit_pct', 1.0),
                    exit_signals=exit_signals_list
                )
                
                if trade:
                    # Add sequential transaction number for ordering
                    trade['transaction_number'] = transaction_number
                    transaction_number += 1
                    all_trades.append(trade)
                    
                    if verbose:
                        if exit_check.get('partial_exit', False):
                            print(f"üìä PARTIAL EXIT ({int(exit_check['exit_pct']*100)}%): {exit_date.strftime('%Y-%m-%d')} @ ${exit_price:.2f} - {exit_check['exit_type']} - {exit_check['reason']}")
                        else:
                            print(f"üö™ EXIT: {exit_date.strftime('%Y-%m-%d')} @ ${exit_price:.2f} - {exit_check['exit_type']} - {exit_check['reason']}")
                            print(f"   Return: {trade['profit_pct']:.2f}%, R-Multiple: {trade['r_multiple']:.2f}R, Held: {trade['bars_held']} days")
        
        # Check for entry signals on this bar (only if no active position)
        if ticker not in risk_mgr.active_positions:
            has_entry_signal = any(df.iloc[idx][sig] for sig in entry_signals)
            
            if has_entry_signal:
                # Entry signal fired - check if we can enter next day
                if idx + 1 >= len(df):
                    continue  # No next day data
                
                # Entry price = next day's open (realistic execution)
                entry_price = df.iloc[idx + 1]['Open']
                entry_date = df.index[idx + 1]
                
                # Extract signal metadata at signal bar (idx, not idx+1)
                triggered_entries = [sig for sig in entry_signals if df.iloc[idx][sig]]
                
                # Extract signal scores at signal bar
                signal_scores = {}
                if 'Accumulation_Score' in df.columns:
                    signal_scores['Accumulation_Score'] = float(df.iloc[idx]['Accumulation_Score'])
                if 'Moderate_Buy_Score' in df.columns and df.iloc[idx].get('Moderate_Buy', False):
                    signal_scores['Moderate_Buy_Score'] = float(df.iloc[idx]['Moderate_Buy_Score'])
                if 'Profit_Taking_Score' in df.columns:
                    signal_scores['Profit_Taking_Score'] = float(df.iloc[idx]['Profit_Taking_Score'])
                
                # Capture regime status from pre-computed DataFrame columns
                # This avoids API calls during backtest loop (data was pre-fetched)
                regime_status = {
                    'ticker': ticker,
                    'market_regime_ok': bool(df.iloc[idx].get('spy_regime_ok', False)),
                    'sector_etf': str(df.iloc[idx].get('sector_etf', 'SPY')),
                    'sector_regime_ok': bool(df.iloc[idx].get('primary_sector_regime_ok', False)),
                    # All 11 sector ETF regimes
                    'xlk_regime_ok': bool(df.iloc[idx].get('xlk_regime_ok', False)),
                    'xlf_regime_ok': bool(df.iloc[idx].get('xlf_regime_ok', False)),
                    'xlv_regime_ok': bool(df.iloc[idx].get('xlv_regime_ok', False)),
                    'xle_regime_ok': bool(df.iloc[idx].get('xle_regime_ok', False)),
                    'xly_regime_ok': bool(df.iloc[idx].get('xly_regime_ok', False)),
                    'xlp_regime_ok': bool(df.iloc[idx].get('xlp_regime_ok', False)),
                    'xli_regime_ok': bool(df.iloc[idx].get('xli_regime_ok', False)),
                    'xlu_regime_ok': bool(df.iloc[idx].get('xlu_regime_ok', False)),
                    'xlre_regime_ok': bool(df.iloc[idx].get('xlre_regime_ok', False)),
                    'xlb_regime_ok': bool(df.iloc[idx].get('xlb_regime_ok', False)),
                    'xlc_regime_ok': bool(df.iloc[idx].get('xlc_regime_ok', False))
                }
                
                # Calculate initial stop using RiskManager
                try:
                    stop_price = risk_mgr.calculate_initial_stop(df, idx)
                    
                    # Open position with signal metadata including regime status
                    position = risk_mgr.open_position(
                        ticker=ticker,
                        entry_date=entry_date,
                        entry_price=entry_price,
                        stop_price=stop_price,
                        entry_idx=idx + 1,  # Entry happens next day
                        df=df,
                        entry_signals=triggered_entries,
                        signal_scores=signal_scores,
                        regime_status=regime_status
                    )
                    
                    if verbose:
                        print(f"‚úÖ ENTRY: {entry_date.strftime('%Y-%m-%d')} @ ${entry_price:.2f}, Stop: ${stop_price:.2f}, Size: {position['position_size']} shares")
                    
                except (KeyError, ValueError) as e:
                    if verbose:
                        print(f"‚ö†Ô∏è Could not open position on {current_date.strftime('%Y-%m-%d')}: {e}")
                    continue
    
    # Close any remaining open positions at last price
    if ticker in risk_mgr.active_positions:
        last_price = df.iloc[-1]['Close']
        last_date = df.index[-1]
        
        trade = risk_mgr.close_position(
            ticker=ticker,
            exit_price=last_price,
            exit_type='END_OF_DATA',
            exit_date=last_date
        )
        
        if trade:
            # Add sequential transaction number
            trade['transaction_number'] = transaction_number
            transaction_number += 1
            all_trades.append(trade)
            if verbose:
                print(f"‚è∏Ô∏è Position closed at end of data: {last_date.strftime('%Y-%m-%d')} @ ${last_price:.2f}")
    
    # Generate comprehensive analysis
    if all_trades:
        analysis = analyze_risk_managed_trades(all_trades)
        ending_equity = risk_mgr.equity
        net_profit = ending_equity - risk_mgr.starting_equity
        analysis['Starting Equity'] = f"${risk_mgr.starting_equity:,.0f}"
        analysis['Ending Equity'] = f"${ending_equity:,.0f}"
        analysis['Net Profit $'] = f"${net_profit:,.0f}"
        analysis['Return %'] = f"{(net_profit / risk_mgr.starting_equity * 100):.2f}%"
        analysis.setdefault('Total Dollar P&L', analysis['Net Profit $'])
        report = generate_risk_managed_report(ticker, all_trades, analysis, account_value, risk_pct)
        
        if verbose:
            print("\n" + report)
        
        # Save to file if requested
        if save_to_file:
            os.makedirs(output_dir, exist_ok=True)
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"{ticker}_risk_managed_backtest_{timestamp}.txt"
            filepath = os.path.join(output_dir, filename)
            
            with open(filepath, 'w') as f:
                f.write(report)
            
            if verbose:
                print(f"\nüíæ Risk-managed backtest report saved: {filename}")
        
        return {
            'trades': all_trades,
            'risk_manager': risk_mgr,
            'analysis': analysis,
            'report': report
        }
    else:
        print("\n‚ö†Ô∏è No trades generated in this analysis period")
        return {
            'trades': [],
            'risk_manager': risk_mgr,
            'analysis': {},
            'report': "No trades generated"
        }


def generate_risk_managed_report(
    ticker: str,
    trades: List[Dict],
    analysis: Dict,
    account_value: float,
    risk_pct: float
) -> str:
    """
    Generate comprehensive risk-managed backtest report.
    
    Args:
        ticker: Stock symbol
        trades: List of trade dictionaries
        analysis: Analysis results from analyze_risk_managed_trades()
        account_value: Account value used
        risk_pct: Risk percentage used
        
    Returns:
        str: Formatted report
    """
    report_lines = []
    
    report_lines.append("=" * 70)
    report_lines.append(f"üéØ RISK-MANAGED BACKTEST REPORT: {ticker.upper()}")
    report_lines.append(f"Item #5: P&L-Aware Exit Logic Implementation")
    report_lines.append("=" * 70)
    report_lines.append("")
    
    # Configuration
    report_lines.append("‚öôÔ∏è RISK MANAGEMENT CONFIGURATION:")
    report_lines.append(f"  Starting Equity: ${account_value:,.0f}")
    report_lines.append(f"  Risk Per Trade: {risk_pct}% (initial ${account_value * (risk_pct/100):,.0f})")
    report_lines.append(f"  Ending Equity: {analysis.get('Ending Equity', 'N/A')}")
    report_lines.append(f"  Net Profit: {analysis.get('Net Profit $', 'N/A')} ({analysis.get('Return %', 'N/A')})")
    report_lines.append(f"  Total Dollar P&L: {analysis.get('Total Dollar P&L', 'N/A')}")
    report_lines.append("")
    
    # Transaction Cost Impact Analysis
    if trades and 'net_pnl' in trades[0]:
        report_lines.append("üí∞ TRANSACTION COST IMPACT:")
        
        total_gross = sum(t.get('gross_pnl', 0) for t in trades)
        total_net = sum(t.get('net_pnl', 0) for t in trades)
        total_commissions = sum(t.get('total_commission', 0) for t in trades)
        total_slippage_cost = sum(t.get('slippage_cost', 0) for t in trades)
        
        # Calculate percentage impacts
        slippage_pct_impact = (total_slippage_cost / abs(total_gross) * 100) if total_gross != 0 else 0
        commission_pct_impact = (total_commissions / abs(total_gross) * 100) if total_gross != 0 else 0
        total_cost_pct = (abs(total_gross - total_net) / abs(total_gross) * 100) if total_gross != 0 else 0
        
        report_lines.append(f"  Gross P&L:           ${total_gross:,.0f} (before costs)")
        report_lines.append(f"  Slippage Cost:       ${total_slippage_cost:,.0f} ({slippage_pct_impact:.2f}% of gross)")
        report_lines.append(f"  Commission Cost:     ${total_commissions:,.0f} ({commission_pct_impact:.2f}% of gross)")
        report_lines.append(f"  Total Costs:         ${abs(total_gross - total_net):,.0f} ({total_cost_pct:.2f}% of gross)")
        report_lines.append(f"  Net P&L:             ${total_net:,.0f} (after costs)")
        report_lines.append("")
        
        # Per-trade average costs
        if len(trades) > 0:
            avg_slippage_per_trade = total_slippage_cost / len(trades)
            avg_commission_per_trade = total_commissions / len(trades)
            
            report_lines.append(f"  Average Cost per Trade:")
            report_lines.append(f"    Slippage:          ${avg_slippage_per_trade:,.2f}")
            report_lines.append(f"    Commission:        ${avg_commission_per_trade:,.2f}")
            report_lines.append(f"    Total:             ${(avg_slippage_per_trade + avg_commission_per_trade):,.2f}")
            report_lines.append("")
    
    
    # Overall Performance
    report_lines.append("üìä OVERALL PERFORMANCE:")
    report_lines.append(f"  Total Trades: {analysis['Total Trades']}")
    report_lines.append(f"  Win Rate: {analysis['Win Rate']}")
    report_lines.append(f"  Average R-Multiple: {analysis['Average R-Multiple']}")
    report_lines.append(f"  Average Profit %: {analysis['Average Profit %']}")
    report_lines.append(f"  Average Holding Period: {analysis['Average Bars Held']}")
    report_lines.append(f"  Profit Scaling Used: {analysis['Profit Scaling Used']} trades")
    report_lines.append("")
    
    # Exit Type Breakdown
    report_lines.append("üö™ EXIT TYPE DISTRIBUTION:")
    exit_breakdown = analysis['Exit Type Breakdown']
    for exit_type, count in exit_breakdown.items():
        emoji = {
            'Time Stops': '‚è∞',
            'Hard Stops': 'üõë',
            'Momentum Fails': 'üí®',
            'Profit Targets': 'üéØ',
            'Trailing Stops': 'üìà'
        }.get(exit_type, '‚Ä¢')
        report_lines.append(f"  {emoji} {exit_type}: {count}")
    report_lines.append("")
    
    # R-Multiple Distribution
    report_lines.append("üìà R-MULTIPLE DISTRIBUTION:")
    r_dist = analysis['R-Multiple Distribution']
    report_lines.append(f"  üöÄ Trades > +2R: {r_dist['Trades > +2R']} (home runs)")
    report_lines.append(f"  ‚úÖ Trades +1R to +2R: {r_dist['Trades +1R to +2R']} (solid wins)")
    report_lines.append(f"  üí° Trades 0 to +1R: {r_dist['Trades 0 to +1R']} (small wins)")
    report_lines.append(f"  ‚ùå Losing Trades: {r_dist['Losing Trades']} (losses)")
    report_lines.append("")
    
    # Best/Worst Trades
    report_lines.append("üèÜ BEST & WORST TRADES:")
    report_lines.append(f"  Best Trade: {analysis['Best Trade']}")
    report_lines.append(f"  Worst Trade: {analysis['Worst Trade']}")
    report_lines.append(f"  Peak R-Multiple Avg: {analysis['Peak R-Multiple Avg']} (best unrealized P&L)")
    report_lines.append("")
    
    # Detailed Trade Log
    report_lines.append("üìã DETAILED TRADE LOG:")
    report_lines.append("-" * 70)
    
    for trade in trades:
        txn_num = trade.get('transaction_number', '?')
        entry_date = trade['entry_date'].strftime('%Y-%m-%d')
        exit_date = trade['exit_date'].strftime('%Y-%m-%d') if trade.get('exit_date') else 'OPEN'
        
        # Format entry signals for display
        entry_signals = trade.get('entry_signals', [])
        if entry_signals:
            entry_signals_str = f" ({', '.join(entry_signals)})"
        else:
            entry_signals_str = ""
        
        # Format exit signals for display
        exit_signals = trade.get('exit_signals', [])
        if exit_signals:
            exit_signals_str = f": {', '.join(exit_signals)}"
        else:
            exit_signals_str = ""
        
        report_lines.append(f"\nTrade #{txn_num}:")
        report_lines.append(f"  Entry: {entry_date} @ ${trade['entry_price']:.2f}{entry_signals_str}")
        
        # Add regime status at entry
        regime_status = trade.get('regime_status', {})
        if regime_status:
            spy_ok = regime_status.get('market_regime_ok', False)
            sector_ok = regime_status.get('sector_regime_ok', False)
            sector_etf = regime_status.get('sector_etf', 'N/A')
            
            spy_icon = '‚úÖ' if spy_ok else '‚ùå'
            sector_icon = '‚úÖ' if sector_ok else '‚ùå'
            
            report_lines.append(f"  Regime: SPY {spy_icon} | {sector_etf} {sector_icon}")
        
        report_lines.append(f"  Exit:  {exit_date} @ ${trade['exit_price']:.2f} ({trade['exit_type']}{exit_signals_str})")
        report_lines.append(f"  Result: {trade['profit_pct']:+.2f}% | {trade['r_multiple']:+.2f}R")
        report_lines.append(f"  Held: {trade['bars_held']} days")
        report_lines.append(f"  Position: {trade['position_size']} shares")
        
        # Add signal scores if available
        signal_scores = trade.get('signal_scores', {})
        if signal_scores:
            score_parts = []
            for score_name, score_value in signal_scores.items():
                if score_value and not pd.isna(score_value):
                    score_parts.append(f"{score_name}: {score_value:.1f}")
            if score_parts:
                report_lines.append(f"  Signal Scores: {', '.join(score_parts)}")
        
        if 'dollar_pnl' in trade:
            report_lines.append(f"  Dollar P&L: ${trade['dollar_pnl']:,.2f}")
        if 'equity_after_trade' in trade:
            report_lines.append(f"  Equity After Trade: ${trade['equity_after_trade']:,.2f}")
        
        if trade.get('partial_exit', False):
            report_lines.append(f"  Note: Partial exit ({int(trade.get('exit_pct', 1.0)*100)}%)")
        
        if trade.get('profit_taken_50pct', False):
            report_lines.append(f"  Profit Scaling: 50% taken at +2R, remainder trailed")
        
        if 'peak_r_multiple' in trade and trade['peak_r_multiple'] > trade['r_multiple']:
            report_lines.append(f"  Peak: {trade['peak_r_multiple']:.2f}R (gave back {trade['peak_r_multiple'] - trade['r_multiple']:.2f}R)")
    
    report_lines.append("")
    report_lines.append("=" * 70)
    report_lines.append("")
    
    # Key Insights
    report_lines.append("üí° KEY INSIGHTS:")
    report_lines.append("")
    
    # Parse win rate
    win_rate_str = analysis['Win Rate']
    win_rate = float(win_rate_str.rstrip('%'))
    
    if win_rate >= 60:
        report_lines.append("  ‚úÖ System shows strong positive edge (>60% win rate)")
    elif win_rate >= 50:
        report_lines.append("  ‚úì System is profitable but could be improved (50-60% win rate)")
    else:
        report_lines.append("  ‚ö†Ô∏è System needs refinement (<50% win rate)")
    
    # Parse R-multiple
    avg_r_str = analysis['Average R-Multiple']
    avg_r = float(avg_r_str.rstrip('R'))
    
    if avg_r >= 1.5:
        report_lines.append("  ‚úÖ Excellent risk-reward ratio (>1.5R average)")
    elif avg_r >= 1.0:
        report_lines.append("  ‚úì Good risk-reward ratio (1.0-1.5R average)")
    elif avg_r > 0:
        report_lines.append("  ‚ö†Ô∏è Risk-reward ratio could be improved (<1.0R average)")
    else:
        report_lines.append("  ‚ùå Negative expectancy - losing system")
    
    # Profit scaling effectiveness
    profit_scaled = analysis['Profit Scaling Used']
    total_trades = analysis['Total Trades']
    
    if profit_scaled > 0:
        scaling_pct = (profit_scaled / total_trades) * 100
        report_lines.append(f"  üìä Profit scaling used in {scaling_pct:.0f}% of trades")
        
        if scaling_pct >= 20:
            report_lines.append("  ‚úÖ Good mix of winners reaching +2R target")
        else:
            report_lines.append("  üí° Few trades reaching +2R - consider wider targets or better entries")
    
    # Exit type analysis
    time_stops = exit_breakdown.get('Time Stops', 0)
    if time_stops > total_trades * 0.3:
        report_lines.append(f"  ‚ö†Ô∏è High time stop rate ({time_stops}/{total_trades}) - many trades going nowhere")
    
    momentum_fails = exit_breakdown.get('Momentum Fails', 0)
    if momentum_fails > total_trades * 0.2:
        report_lines.append(f"  üëÄ Watch momentum failures ({momentum_fails}/{total_trades}) - trend reversing quickly")
    
    hard_stops = exit_breakdown.get('Hard Stops', 0)
    if hard_stops > total_trades * 0.3:
        report_lines.append(f"  üõë High hard stop rate ({hard_stops}/{total_trades}) - consider tighter entries or better setups")
    
    report_lines.append("")
    report_lines.append("üìù RISK MANAGEMENT RULES IN USE:")
    report_lines.append("  ‚Ä¢ Initial Stop: min(swing_low - 0.5*ATR, VWAP - 1*ATR)")
    report_lines.append("  ‚Ä¢ Hard Stop: Exit below initial stop (capital protection)")
    report_lines.append("  ‚Ä¢ Time Stop: Exit after 12 bars if <+1R (dead positions)")
    report_lines.append("  ‚Ä¢ Regular Exit Signals: Distribution Warning, Momentum Exhaustion, Sell Signal, etc.")
    report_lines.append("  ‚Ä¢ Profit Target: Scale 50% at +2R")
    report_lines.append("  ‚Ä¢ Trailing Stop: 10-day low after +2R achieved")
    report_lines.append("")
    report_lines.append("üí° EXIT LOGIC UPDATE (Nov 2025):")
    report_lines.append("  Removed aggressive momentum check (CMF<0/price<VWAP) that caused 93% immediate exits.")
    report_lines.append("  Now uses proven exit signals + risk management stops for optimal trade management.")
    report_lines.append("")
    
    return "\n".join(report_lines)


if __name__ == "__main__":
    print("This module is designed to be imported by vol_analysis.py")
    print("Use: python vol_analysis.py TICKER --backtest")
    print("Use: python vol_analysis.py TICKER --risk-managed")
    print("Use: python vol_analysis.py TICKER --optimize-thresholds")
