"""
Empirically Validated Signal Thresholds Configuration

This module stores optimal signal thresholds discovered through backtest optimization.
All thresholds are validated by historical trading performance and include rationale
for why each threshold was selected.

Usage:
    from threshold_config import OPTIMAL_THRESHOLDS
    
    moderate_threshold = OPTIMAL_THRESHOLDS['moderate_buy']['threshold']
    rationale = OPTIMAL_THRESHOLDS['moderate_buy']['rationale']

Generated by: Item #8 (Empirical Signal Threshold Optimization)
Last Updated: 2025-11-04
"""

from datetime import datetime
from typing import Dict, Any

# Empirically validated optimal thresholds based on backtest performance
OPTIMAL_THRESHOLDS: Dict[str, Dict[str, Any]] = {
    'moderate_buy': {
        'threshold': 6.5,
        'rationale': 'THRESHOLD OPTIMIZED (Dec 2025): 45% better expectancy than 6.0 baseline with only 10% fewer trades',
        'backtest_results': {
            'win_rate': 70.0,
            'expectancy': 13.35,
            'sample_size': 434,
            'profit_factor': 4.39,
            'median_return': 9.16,
            'trades_analyzed': 434,
            'tickers_validated': 24,
            'filtered_percentage': 10,  # Filters 47 marginal trades (6.0-6.5 range)
            'last_validated': '2025-12-01'
        },
        'validation_notes': [
            '434 trades across 24 tickers - robust validation',
            '70.0% win rate (vs 68.0% at 6.0 threshold)',
            'Expectancy +13.35% (vs +9.17% at 6.0) - 45% improvement',
            'Median return +9.16% (vs +6.24% at 6.0) - 47% improvement',
            'Quality over quantity: Filtering 47 marginal trades significantly improved performance',
            'Threshold 7.5 optimal (71% win, +14.08%) but 6.5 preferred for trade frequency',
            'Signal logic: Accumulation ‚â•5, pullback zone (below 5-day but above 20-day MA), volume normalizing'
        ],
        'usage_context': 'PRIMARY ENTRY SIGNAL - Pullback strategy validated in both choppy and rally markets'
    },
    
    'profit_taking': {
        'threshold': 7.0,
        'rationale': 'Maintains 95%+ win rate with strong average returns',
        'backtest_results': {
            'win_rate': 96.1,
            'expectancy': 15.24,
            'sample_size': 42,
            'profit_factor': 24.8,
            'avg_return': 15.24,
            'trades_analyzed': 67,
            'filtered_percentage': 37,  # Filters out 37% of signals
            'last_validated': '2025-11-04'
        },
        'validation_notes': [
            '96.1% win rate indicates highly reliable exit timing',
            'Average return of +15.24% shows effective profit capture',
            'Large sample (42 trades) provides high confidence',
            'Profit factor of 24.8 indicates exceptional risk/reward'
        ],
        'usage_context': 'Primary exit signal - use for taking profits on winning positions'
    },
    
    'stealth_accumulation': {
        'threshold': 4.0,
        'rationale': 'MULTI-TICKER VALIDATED (Nov 2025): Minimal filtering, works across diverse stocks',
        'backtest_results': {
            'win_rate': 53.2,
            'expectancy': 11.75,
            'sample_size': 205,
            'profit_factor': 2.14,
            'median_return': 2.29,
            'trades_analyzed': 205,
            'tickers_validated': 23,
            'filtered_percentage': 0,  # Minimal filtering at ‚â•4.0
            'last_validated': '2025-11-08'
        },
        'validation_notes': [
            '205 trades across 23 tickers - robust sample size',
            '53.2% win rate provides solid positive edge',
            'Expectancy of +11.75% indicates strong risk/reward',
            'Minimal threshold (‚â•4.0) needed - signal quality is inherent to design',
            'Catches accumulation before the move - complementary to Moderate Buy pullbacks'
        ],
        'usage_context': 'Primary early-entry strategy - use for position building before momentum'
    }
}


# Threshold quality assessment functions
def get_threshold_quality(signal_type: str) -> str:
    """
    Get quality assessment for a signal threshold.
    
    Args:
        signal_type: Key from OPTIMAL_THRESHOLDS
        
    Returns:
        str: Quality assessment (EXCELLENT, GOOD, FAIR, POOR)
    """
    if signal_type not in OPTIMAL_THRESHOLDS:
        return "UNKNOWN"
    
    metrics = OPTIMAL_THRESHOLDS[signal_type]['backtest_results']
    win_rate = metrics['win_rate']
    expectancy = metrics['expectancy']
    sample_size = metrics['sample_size']
    
    # Quality criteria based on backtest performance
    if (expectancy > 2.0 and win_rate > 60 and sample_size >= 25):
        return "EXCELLENT"
    elif (expectancy > 1.0 and win_rate > 55 and sample_size >= 20):
        return "GOOD"
    elif (expectancy > 0 and win_rate > 50 and sample_size >= 15):
        return "FAIR"
    else:
        return "POOR"


def get_threshold_summary(signal_type: str) -> str:
    """
    Get formatted summary of threshold performance.
    
    Args:
        signal_type: Key from OPTIMAL_THRESHOLDS
        
    Returns:
        str: Formatted summary string
    """
    if signal_type not in OPTIMAL_THRESHOLDS:
        return f"No threshold data available for {signal_type}"
    
    config = OPTIMAL_THRESHOLDS[signal_type]
    metrics = config['backtest_results']
    quality = get_threshold_quality(signal_type)
    
    return (f"Threshold ‚â•{config['threshold']:.1f} | "
            f"Win Rate: {metrics['win_rate']:.1f}% | "
            f"Expectancy: {metrics['expectancy']:+.2f}% | "
            f"Sample: {metrics['sample_size']} trades | "
            f"Quality: {quality}")


def is_threshold_reliable(signal_type: str, min_sample_size: int = 20) -> bool:
    """
    Check if a threshold has sufficient sample size for reliability.
    
    Args:
        signal_type: Key from OPTIMAL_THRESHOLDS
        min_sample_size: Minimum required sample size
        
    Returns:
        bool: True if threshold is reliable
    """
    if signal_type not in OPTIMAL_THRESHOLDS:
        return False
    
    sample_size = OPTIMAL_THRESHOLDS[signal_type]['backtest_results']['sample_size']
    return sample_size >= min_sample_size


def get_all_thresholds_summary() -> str:
    """
    Get formatted summary of all validated thresholds.
    
    Returns:
        str: Multi-line summary of all thresholds
    """
    summary_lines = []
    summary_lines.append("üìä EMPIRICALLY VALIDATED THRESHOLDS SUMMARY")
    summary_lines.append("=" * 50)
    summary_lines.append("")
    
    for signal_type in OPTIMAL_THRESHOLDS:
        config = OPTIMAL_THRESHOLDS[signal_type]
        quality = get_threshold_quality(signal_type)
        
        # Quality emoji
        quality_emoji = {
            "EXCELLENT": "‚úÖ",
            "GOOD": "‚úÖ", 
            "FAIR": "‚úì",
            "POOR": "‚ö†Ô∏è",
            "UNKNOWN": "‚ùì"
        }.get(quality, "‚ùì")
        
        summary_lines.append(f"{quality_emoji} {signal_type.replace('_', ' ').title()}:")
        summary_lines.append(f"   Threshold: ‚â•{config['threshold']:.1f}")
        summary_lines.append(f"   Performance: {get_threshold_summary(signal_type)}")
        summary_lines.append(f"   Usage: {config['usage_context']}")
        summary_lines.append("")
    
    summary_lines.append(f"Last Updated: {datetime.now().strftime('%Y-%m-%d')}")
    summary_lines.append("")
    summary_lines.append("üí° USAGE NOTES:")
    summary_lines.append("‚Ä¢ EXCELLENT/GOOD thresholds: Use for primary trading decisions")
    summary_lines.append("‚Ä¢ FAIR thresholds: Use for secondary signals or smaller positions") 
    summary_lines.append("‚Ä¢ POOR thresholds: Avoid or re-optimize with more data")
    summary_lines.append("‚Ä¢ All thresholds based on entry-to-exit backtest validation")
    
    return "\n".join(summary_lines)


# Version and metadata
THRESHOLD_CONFIG_VERSION = "2.0.0"
LAST_OPTIMIZATION_DATE = "2025-12-01"
OPTIMIZATION_PERIOD = "24mo"  # Period used for threshold validation
MINIMUM_SAMPLE_SIZE = 30      # Minimum trades required for multi-ticker reliability

# Threshold update history (for audit trail)
THRESHOLD_HISTORY = {
    '2025-11-04': {
        'event': 'Initial threshold optimization (Item #8 implementation)',
        'changes': [
            'Created moderate_buy threshold: 6.5 (64.3% win rate, +2.15% expectancy)',
            'Created profit_taking threshold: 7.0 (96.1% win rate, +15.24% return)', 
            'Created stealth_accumulation threshold: 4.5 (58.7% win rate, +1.45% expectancy)'
        ],
        'methodology': 'Backtest optimization across multiple thresholds, selected best expectancy with adequate sample size',
        'validation_period': '12mo',
        'total_trades_analyzed': 187,
        'note': 'Single-ticker optimization - did not generalize to multi-ticker universe'
    },
    '2025-11-08': {
        'event': 'Multi-ticker threshold validation and Moderate Buy redesign',
        'changes': [
            'REDESIGNED moderate_buy signal: Changed from narrow criteria to pullback strategy',
            'Updated moderate_buy threshold: 6.5 ‚Üí 6.0 (59.6% win rate, +21.89% expectancy, 312 trades across 23 tickers)',
            'Updated stealth_accumulation threshold: 4.5 ‚Üí 4.0 (53.2% win rate, +11.75% expectancy, 205 trades across 23 tickers)',
            'Removed profit_taking from entry signals (it\'s an exit signal, tested incorrectly)'
        ],
        'methodology': 'Multi-ticker optimization across 24 tickers over 24-month period. Tested thresholds 4.0-8.0 and selected based on expectancy + win rate composite score with minimum 30 trades and 10 tickers',
        'validation_period': '24mo',
        'total_trades_analyzed': 517,
        'critical_discovery': 'Original Moderate Buy logic failed (21% win rate). Redesigned as pullback strategy - now works with 59.6% win rate!'
    },
    '2025-12-01': {
        'event': 'Threshold sensitivity analysis and optimization',
        'changes': [
            'Updated moderate_buy threshold: 6.0 ‚Üí 6.5 (70.0% win rate, +13.35% expectancy, 434 trades)',
            'Improved expectancy by 45% with only 10% fewer trades',
            'Median return improved 47% (+6.24% ‚Üí +9.16%)',
            'Conservative_config.yaml (6.5 threshold) now system default'
        ],
        'methodology': 'Comparative analysis of actual trade results at different thresholds (6.0, 6.5, 7.5, 8.0+). Analyzed score bucket performance and threshold impact on win rate, expectancy, and sample size',
        'validation_period': '24mo',
        'total_trades_analyzed': 481,
        'key_findings': [
            'Small threshold change (6.0 ‚Üí 6.5) = 45% better expectancy',
            '47 marginal trades (6.0-6.5 range) were dragging down performance',
            'Quality over quantity principle validated',
            '7.5 threshold has best stats (71% win, +14.08%) but 6.5 preferred for trade frequency',
            'Practical trade-off: slight expectancy reduction for 37% more signals vs 7.5'
        ],
        'note': 'User inquiry: "Is 6.5 as good as 8.2?" Answer: 8.2 is ~26% better but 6.5 provides optimal balance of quality and opportunity'
    }
}


if __name__ == "__main__":
    print("üìä EMPIRICALLY VALIDATED SIGNAL THRESHOLDS")
    print("=" * 50)
    print()
    print(get_all_thresholds_summary())
