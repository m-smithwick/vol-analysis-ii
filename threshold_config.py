"""
Empirically Validated Signal Thresholds Configuration

This module stores optimal signal thresholds discovered through backtest optimization.
All thresholds are validated by historical trading performance and include rationale
for why each threshold was selected.

Usage:
    from threshold_config import OPTIMAL_THRESHOLDS
    
    moderate_threshold = OPTIMAL_THRESHOLDS['moderate_buy']['threshold']
    rationale = OPTIMAL_THRESHOLDS['moderate_buy']['rationale']

Generated by: Item #8 (Empirical Signal Threshold Optimization)
Last Updated: 2025-11-04
"""

from datetime import datetime
from typing import Dict, Any

# Global minimum accumulation score for all trades
# Updated 2025-11-22: Based on 694-trade analysis showing ‚â•7.0 optimizes expectancy
MINIMUM_ACCUMULATION_SCORE = 7.0

# Empirically validated optimal thresholds based on backtest performance
OPTIMAL_THRESHOLDS: Dict[str, Dict[str, Any]] = {
    'moderate_buy': {
        'threshold': 6.0,
        'rationale': 'REDESIGNED PULLBACK STRATEGY (Nov 2025): Validated on 24-ticker, 24-month universe',
        'backtest_results': {
            'win_rate': 59.6,
            'expectancy': 21.89,
            'sample_size': 312,
            'profit_factor': 2.98,
            'median_return': 5.21,
            'trades_analyzed': 312,
            'tickers_validated': 23,
            'filtered_percentage': 0,  # Minimal filtering at ‚â•6.0
            'last_validated': '2025-11-08'
        },
        'validation_notes': [
            '312 trades across 23 tickers - excellent generalization',
            '59.6% win rate shows strong positive edge',
            'Expectancy of +21.89% indicates excellent risk/reward',
            'Redesigned to catch pullbacks in uptrends (not competing with other signals)',
            'Signal logic: Accumulation ‚â•5, pullback zone (below 5-day but above 20-day MA), volume normalizing'
        ],
        'usage_context': 'Pullback entry strategy - complementary to Stealth Accumulation'
    },
    
    'profit_taking': {
        'threshold': 7.0,
        'rationale': 'Maintains 95%+ win rate with strong average returns',
        'backtest_results': {
            'win_rate': 96.1,
            'expectancy': 15.24,
            'sample_size': 42,
            'profit_factor': 24.8,
            'avg_return': 15.24,
            'trades_analyzed': 67,
            'filtered_percentage': 37,  # Filters out 37% of signals
            'last_validated': '2025-11-04'
        },
        'validation_notes': [
            '96.1% win rate indicates highly reliable exit timing',
            'Average return of +15.24% shows effective profit capture',
            'Large sample (42 trades) provides high confidence',
            'Profit factor of 24.8 indicates exceptional risk/reward'
        ],
        'usage_context': 'Primary exit signal - use for taking profits on winning positions'
    },
    
    'stealth_accumulation': {
        'threshold': 4.0,
        'rationale': 'MULTI-TICKER VALIDATED (Nov 2025): Minimal filtering, works across diverse stocks',
        'backtest_results': {
            'win_rate': 53.2,
            'expectancy': 11.75,
            'sample_size': 205,
            'profit_factor': 2.14,
            'median_return': 2.29,
            'trades_analyzed': 205,
            'tickers_validated': 23,
            'filtered_percentage': 0,  # Minimal filtering at ‚â•4.0
            'last_validated': '2025-11-08'
        },
        'validation_notes': [
            '205 trades across 23 tickers - robust sample size',
            '53.2% win rate provides solid positive edge',
            'Expectancy of +11.75% indicates strong risk/reward',
            'Minimal threshold (‚â•4.0) needed - signal quality is inherent to design',
            'Catches accumulation before the move - complementary to Moderate Buy pullbacks'
        ],
        'usage_context': 'Primary early-entry strategy - use for position building before momentum'
    }
}


# Threshold quality assessment functions
def get_threshold_quality(signal_type: str) -> str:
    """
    Get quality assessment for a signal threshold.
    
    Args:
        signal_type: Key from OPTIMAL_THRESHOLDS
        
    Returns:
        str: Quality assessment (EXCELLENT, GOOD, FAIR, POOR)
    """
    if signal_type not in OPTIMAL_THRESHOLDS:
        return "UNKNOWN"
    
    metrics = OPTIMAL_THRESHOLDS[signal_type]['backtest_results']
    win_rate = metrics['win_rate']
    expectancy = metrics['expectancy']
    sample_size = metrics['sample_size']
    
    # Quality criteria based on backtest performance
    if (expectancy > 2.0 and win_rate > 60 and sample_size >= 25):
        return "EXCELLENT"
    elif (expectancy > 1.0 and win_rate > 55 and sample_size >= 20):
        return "GOOD"
    elif (expectancy > 0 and win_rate > 50 and sample_size >= 15):
        return "FAIR"
    else:
        return "POOR"


def get_threshold_summary(signal_type: str) -> str:
    """
    Get formatted summary of threshold performance.
    
    Args:
        signal_type: Key from OPTIMAL_THRESHOLDS
        
    Returns:
        str: Formatted summary string
    """
    if signal_type not in OPTIMAL_THRESHOLDS:
        return f"No threshold data available for {signal_type}"
    
    config = OPTIMAL_THRESHOLDS[signal_type]
    metrics = config['backtest_results']
    quality = get_threshold_quality(signal_type)
    
    return (f"Threshold ‚â•{config['threshold']:.1f} | "
            f"Win Rate: {metrics['win_rate']:.1f}% | "
            f"Expectancy: {metrics['expectancy']:+.2f}% | "
            f"Sample: {metrics['sample_size']} trades | "
            f"Quality: {quality}")


def is_threshold_reliable(signal_type: str, min_sample_size: int = 20) -> bool:
    """
    Check if a threshold has sufficient sample size for reliability.
    
    Args:
        signal_type: Key from OPTIMAL_THRESHOLDS
        min_sample_size: Minimum required sample size
        
    Returns:
        bool: True if threshold is reliable
    """
    if signal_type not in OPTIMAL_THRESHOLDS:
        return False
    
    sample_size = OPTIMAL_THRESHOLDS[signal_type]['backtest_results']['sample_size']
    return sample_size >= min_sample_size


def get_all_thresholds_summary() -> str:
    """
    Get formatted summary of all validated thresholds.
    
    Returns:
        str: Multi-line summary of all thresholds
    """
    summary_lines = []
    summary_lines.append("üìä EMPIRICALLY VALIDATED THRESHOLDS SUMMARY")
    summary_lines.append("=" * 50)
    summary_lines.append("")
    
    for signal_type in OPTIMAL_THRESHOLDS:
        config = OPTIMAL_THRESHOLDS[signal_type]
        quality = get_threshold_quality(signal_type)
        
        # Quality emoji
        quality_emoji = {
            "EXCELLENT": "‚úÖ",
            "GOOD": "‚úÖ", 
            "FAIR": "‚úì",
            "POOR": "‚ö†Ô∏è",
            "UNKNOWN": "‚ùì"
        }.get(quality, "‚ùì")
        
        summary_lines.append(f"{quality_emoji} {signal_type.replace('_', ' ').title()}:")
        summary_lines.append(f"   Threshold: ‚â•{config['threshold']:.1f}")
        summary_lines.append(f"   Performance: {get_threshold_summary(signal_type)}")
        summary_lines.append(f"   Usage: {config['usage_context']}")
        summary_lines.append("")
    
    summary_lines.append(f"Last Updated: {datetime.now().strftime('%Y-%m-%d')}")
    summary_lines.append("")
    summary_lines.append("üí° USAGE NOTES:")
    summary_lines.append("‚Ä¢ EXCELLENT/GOOD thresholds: Use for primary trading decisions")
    summary_lines.append("‚Ä¢ FAIR thresholds: Use for secondary signals or smaller positions") 
    summary_lines.append("‚Ä¢ POOR thresholds: Avoid or re-optimize with more data")
    summary_lines.append("‚Ä¢ All thresholds based on entry-to-exit backtest validation")
    
    return "\n".join(summary_lines)


# Version and metadata
THRESHOLD_CONFIG_VERSION = "2.0.0"
LAST_OPTIMIZATION_DATE = "2025-11-08"
OPTIMIZATION_PERIOD = "24mo"  # Period used for threshold validation
MINIMUM_SAMPLE_SIZE = 30      # Minimum trades required for multi-ticker reliability

# Threshold update history (for audit trail)
THRESHOLD_HISTORY = {
    '2025-11-04': {
        'event': 'Initial threshold optimization (Item #8 implementation)',
        'changes': [
            'Created moderate_buy threshold: 6.5 (64.3% win rate, +2.15% expectancy)',
            'Created profit_taking threshold: 7.0 (96.1% win rate, +15.24% return)', 
            'Created stealth_accumulation threshold: 4.5 (58.7% win rate, +1.45% expectancy)'
        ],
        'methodology': 'Backtest optimization across multiple thresholds, selected best expectancy with adequate sample size',
        'validation_period': '12mo',
        'total_trades_analyzed': 187,
        'note': 'Single-ticker optimization - did not generalize to multi-ticker universe'
    },
    '2025-11-08': {
        'event': 'Multi-ticker threshold validation and Moderate Buy redesign',
        'changes': [
            'REDESIGNED moderate_buy signal: Changed from narrow criteria to pullback strategy',
            'Updated moderate_buy threshold: 6.5 ‚Üí 6.0 (59.6% win rate, +21.89% expectancy, 312 trades across 23 tickers)',
            'Updated stealth_accumulation threshold: 4.5 ‚Üí 4.0 (53.2% win rate, +11.75% expectancy, 205 trades across 23 tickers)',
            'Removed profit_taking from entry signals (it\'s an exit signal, tested incorrectly)'
        ],
        'methodology': 'Multi-ticker optimization across 24 tickers over 24-month period. Tested thresholds 4.0-8.0 and selected based on expectancy + win rate composite score with minimum 30 trades and 10 tickers',
        'validation_period': '24mo',
        'total_trades_analyzed': 517,
        'critical_discovery': 'Original Moderate Buy logic failed (21% win rate). Redesigned as pullback strategy - now works with 59.6% win rate!'
    }
}


if __name__ == "__main__":
    print("üìä EMPIRICALLY VALIDATED SIGNAL THRESHOLDS")
    print("=" * 50)
    print()
    print(get_all_thresholds_summary())
