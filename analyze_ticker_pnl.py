"""
Ticker PnL analyzer

Loads a LOG_FILE_*.csv trade ledger (generated by batch_backtest.py) and
summarizes profit contribution by ticker. Produces a console summary,
text report, and PNG visualization highlighting the top contributors.

Usage:
    python analyze_ticker_pnl.py path/to/LOG_FILE_*.csv
"""

import argparse
import os
from typing import Tuple

# Ensure matplotlib has a writable cache directory inside the repo.
_BASE_DIR = os.path.dirname(os.path.abspath(__file__))
_MPLCONFIGDIR = os.path.join(_BASE_DIR, ".mplconfig")
_CACHE_DIR = os.path.join(_MPLCONFIGDIR, "cache")
os.makedirs(_CACHE_DIR, exist_ok=True)
os.environ.setdefault("MPLCONFIGDIR", _MPLCONFIGDIR)
os.environ.setdefault("XDG_CACHE_HOME", _CACHE_DIR)

import matplotlib  # noqa: E402

# Use non-interactive backend so the script works in CLI sessions.
matplotlib.use("Agg")
import matplotlib.pyplot as plt  # noqa: E402
import pandas as pd  # noqa: E402


def load_trade_log(csv_path: str) -> pd.DataFrame:
    """Load the trade log CSV and validate required columns."""
    if not os.path.exists(csv_path):
        raise FileNotFoundError(f"Trade log not found: {csv_path}")

    df = pd.read_csv(csv_path)
    required_cols = {"ticker", "dollar_pnl", "transaction_number"}
    missing = required_cols - set(df.columns)
    if missing:
        raise ValueError(
            f"CSV is missing required column(s): {', '.join(sorted(missing))}"
        )
    return df


def compute_ticker_stats(df: pd.DataFrame) -> pd.DataFrame:
    """Aggregate per-ticker performance statistics."""
    grouped = df.groupby("ticker")["dollar_pnl"]
    stats = grouped.agg(
        total_pnl="sum",
        trade_count="count",
        winning_trades=lambda s: (s > 0).sum(),
    )
    stats["avg_pnl_per_trade"] = stats["total_pnl"] / stats["trade_count"]
    stats["win_rate"] = stats["winning_trades"] / stats["trade_count"] * 100.0
    stats["losing_trades"] = stats["trade_count"] - stats["winning_trades"]
    stats["abs_contribution"] = stats["total_pnl"].abs()
    stats = stats.reset_index().sort_values(
        "abs_contribution", ascending=False
    )
    return stats


def render_chart(stats: pd.DataFrame, output_path: str) -> None:
    """Create a horizontal bar chart of ticker contributions."""
    tickers = stats["ticker"]
    contributions = stats["total_pnl"]
    colors = ["#2ca02c" if pnl >= 0 else "#d62728" for pnl in contributions]

    plt.figure(figsize=(10, max(4, len(tickers) * 0.35)))
    bars = plt.barh(tickers, contributions, color=colors, alpha=0.85)
    plt.axvline(0, color="black", linewidth=0.8)
    plt.title("Ticker Contribution to Portfolio PnL")
    plt.xlabel("Total Dollar PnL")
    plt.ylabel("Ticker")

    # Annotate bars with contribution values.
    for bar, pnl in zip(bars, contributions):
        width = bar.get_width()
        xpos = width + (500 if width >= 0 else -500)
        align = "left" if width >= 0 else "right"
        plt.text(
            xpos,
            bar.get_y() + bar.get_height() / 2,
            f"{pnl:,.0f}",
            va="center",
            ha=align,
            fontsize=9,
        )

    plt.tight_layout()
    plt.savefig(output_path, dpi=150)
    plt.close()


def build_report_text(stats: pd.DataFrame, csv_name: str) -> str:
    """Create a text summary of ticker stats."""
    lines = []
    lines.append(f"Ticker PnL Summary for {csv_name}")
    lines.append("-" * 80)
    lines.append(
        f"{'Ticker':<8}{'Trades':>8}{'Wins':>8}{'Losses':>10}"
        f"{'Win %':>10}{'Total PnL':>15}{'Avg/Trade':>15}"
    )
    lines.append("-" * 80)

    for _, row in stats.iterrows():
        lines.append(
            f"{row['ticker']:<8}"
            f"{row['trade_count']:>8.0f}"
            f"{row['winning_trades']:>8.0f}"
            f"{row['losing_trades']:>10.0f}"
            f"{row['win_rate']:>9.1f}%"
            f"{row['total_pnl']:>15,.0f}"
            f"{row['avg_pnl_per_trade']:>15,.0f}"
        )

    total_trades = int(stats["trade_count"].sum())
    aggregated_pnl = stats["total_pnl"].sum()
    lines.append("-" * 80)
    lines.append(
        f"Total Trades: {total_trades} | "
        f"Aggregate PnL: {aggregated_pnl:,.0f}"
    )
    return "\n".join(lines)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Summarize ticker-level contributions from a trade log CSV."
    )
    parser.add_argument(
        "csv_path", help="Path to LOG_FILE_*.csv generated by batch_backtest.py"
    )
    parser.add_argument(
        "--output-dir",
        help="Optional directory for report + chart (defaults to CSV folder)",
    )
    return parser.parse_args()


def determine_output_paths(csv_path: str, output_dir: str = None) -> Tuple[str, str]:
    """Return (chart_path, report_path) derived from the CSV name."""
    base_name = os.path.splitext(os.path.basename(csv_path))[0]
    out_dir = output_dir or os.path.dirname(os.path.abspath(csv_path))
    os.makedirs(out_dir, exist_ok=True)
    chart_path = os.path.join(out_dir, f"{base_name}_ticker_pnl.png")
    report_path = os.path.join(out_dir, f"{base_name}_ticker_pnl.txt")
    return chart_path, report_path


def main() -> None:
    args = parse_args()
    df = load_trade_log(args.csv_path)
    stats = compute_ticker_stats(df)
    if stats.empty:
        print("No trades found in the provided trade log.")
        return

    chart_path, report_path = determine_output_paths(
        args.csv_path, args.output_dir
    )
    render_chart(stats, chart_path)

    report_text = build_report_text(stats, os.path.basename(args.csv_path))
    with open(report_path, "w", encoding="utf-8") as fh:
        fh.write(report_text + "\n")

    print(report_text)
    print()
    print(f"Chart saved to: {chart_path}")
    print(f"Report saved to: {report_path}")


if __name__ == "__main__":
    main()
